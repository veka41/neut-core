import {
- this.bool
- this.bottom
- this.function
- this.i8-array
- this.list
- this.option
- this.product
- this.sum
- this.system
- this.text
- this.top
- this.vector
- this.file
- this.file.flag => FF
- this.file.mode => FM
- this.file.descriptor => FD
- this.text.io => text
- this.queue => Q
- this.external => ext
- this.thread => t
- this.magic => magic
}

variant item {
- Bar(i64)
}

define main(): i64 {
  // channel test
  // t.raw-test()
  // let ch-orig = t.new-channel()
  // text.print("created a channel\n")
  // t.test-lock(ch-orig)

  let ch-orig: t.channel-internal(() -> i64) = t.new-channel()
  text.print("created a channel\n")
  // t.test-lock(ch-orig)
  let ch = magic.cast(t.channel-internal(() -> i64), i64, ch-orig)
  t.send-to-channel(lambda () {1}, magic.cast(i64, t.channel-internal(() -> i64), ch))
  t.send-to-channel(lambda () {2}, magic.cast(i64, t.channel-internal(() -> i64), ch))
  let f =
    detach {
      text.print("I'm the thread that does downloading...\n")
      ext.sleep(2)
      text.print("sending from another thread\n")
      t.send-to-channel(lambda () {3}, magic.cast(i64, t.channel-internal(() -> i64), ch))
      text.print("done\n")
    }
  let g =
    detach {
      ext.sleep(3)
      text.print("sending from another thread (GGG)\n")
      t.send-to-channel(lambda () {4}, magic.cast(i64, t.channel-internal(() -> i64), ch))
      text.print("done\n")
    }
  let v1 = t.receive-from-channel(magic.cast(i64, t.channel-internal(() -> i64), ch))
  let v2 = t.receive-from-channel(magic.cast(i64, t.channel-internal(() -> i64), ch))
  let v3 = t.receive-from-channel(magic.cast(i64, t.channel-internal(() -> i64), ch))
  // let v4 = t.receive-from-channel(magic.cast(i64, t.channel-internal(() -> i64), ch))

  // let result = add-i64(v1(), add-i64(v2(), add-i64(v3(), v4())))

  attach f
  attach g
  // text.print("hello, got the result: ")
  // text.print-i64(result)
  // text.print("\n")

  t.discard-channel(magic.cast(i64, t.channel-internal(i64), ch))


  // let q: Q.queue(i64) = Q.empty()
  // let q = Q.enqueue(1, q)
  // let q = Q.enqueue(2, q)
  // let q = Q.enqueue(3, q)
  // match Q.dequeue(q) {
  // - None =>
  //   Unit
  // - Some(tuple(v, rest)) =>
  //   text.print("the first element: ")
  //   text.print-i64(v)
  //   text.print("\n")
  //   Unit
  // }

  // text.print("thread testing.\n")
  // let some-text = "hello, world!\n"
  // let f1: flow(() -> i64)  =
  //   detach {
  //     ext.sleep(3)
  //     text.print("I'm flow 1.\n")
  //     text.print(some-text)
  //     lambda () { 20: i64 }
  //   }
  // // let flow1-copy = flow1
  // // // let _ = eq-i64(flow1-copy, tau)
  // // let flow1-copy = flow1
  // let flow2 =
  //   detach {
  //     ext.sleep(2)
  //     text.print("I'm flow 2\n")
  //     text.print(some-text)
  //     2: i64
  //   }
  // let longer-flow =
  //   detach {
  //     let value = attach flow2
  //     text.print("I'm the continuation of flow 2\n")
  //     text.print(some-text)
  //     add-i64(value, 10)
  //   }
  // let p3 =
  //   detach {
  //     ext.sleep(1)
  //     text.print("I'm flow 3\n")
  //     text.print(some-text)
  //     3: i64
  //   }
  // text.print("spawned three flows. awaiting...\n")
  // let v1 = attach f1
  // let v3 = attach p3
  // let v2 = attach longer-flow
  // text.print("done. results: \n")
  // // let Bar(result) = v1
  // // text.print-i64(result)
  // // text.print-i64(v1())
  // text.print-i64(v1())
  // text.print("\n")
  // text.print-i64(v2)
  // text.print("\n")
  // text.print-i64(v3)
  // text.print("\n")


  // text.print("input> ")
  // let input-or-none = text.get-line()
  // let _ = input-or-none
  // let _ = input-or-none
  // let _ = input-or-none
  // let _ = input-or-none
  // let copy = input-or-none
  // match copy {
  // - None =>
  //   text.print-line("couldn't get from input")
  // - Some(input) =>
  //   text.print-line("result:")
  //   ext.sleep(3)
  //   let _ on input = text.print-line(input)
  //   let _ = input
  //   Unit
  // }

  // let file = open("./sample6", FF.for-rw-append(), FM.default-file-mode())
  // let _ = text.write("hello, world!\n", file)
  // close(file)

  // let file = open("./sample6", FF.for-r(), FM.default-file-mode())
  // let content = text.read(file)
  // text.print("result:\n")
  // match content {
  // - None =>
  //   text.print("couldn't read the file\n")
  // - Some(content) =>
  //   let _ on content = text.print(content)
  //   let _ = content
  //   close(file)
  // }

  // print("\n")

  // let input = read(FD.stdin(), 800)

  // print("user input:\n")

  // let _ on input = print(input)

  // let size = shl-i64(2, 8)
  // print-i64(size)

  // let str1 = "hello, "
  // let str2 = "world!"
  // // let txt = !"hello, world"
  // // let a = txt
  // // let a = txt
  // // let a = txt
  // // print-line("hello, world!\n")
  // let text-from-int = from-i64(-9874123849123749)
  // let _ on text-from-int = print-line(text-from-int)
  // // print-i64(1234)
  // // print-line(str1)
  // // print-line(str2)
  // let str = this.text.append(str1, str2)
  // let _ on str = {
  //   print-line("↓↓↓")
  //   print-line(str)
  //   print-line("↑↑↑")
  // }
  // let empty = empty()
  // match naive-tail(empty) {
  // - None =>
  //   print-line("nothing")
  // - Some(new-str) =>
  //   let _ on new-str = print-line(new-str)
  //   let a = new-str
  //   let a = new-str
  //   let a = new-str
  //   let a = new-str
  //   print-line("done")
  // }

  // let xs = ["foo", "bar", "buz"]
  // let sample on xs = intercalate(", ", xs)
  // let _ on sample = print-line(sample)

  // print-character(48)
  // print-line("print-i64: ")
  // print-i64(-4218934)
  // print-line("here")
  // let xs = [104, 101, 108, 108, 111, 10]
  // let arr = i8-array-new(xs)
  // let vec = vector-new(xs)
  // let v1 on arr = i8-array-access(arr, 2)
  // let v0 on vec = vector-access(vec, 2)
  // let a = vec
  // let b = vec
  // let txt = "hello, world! this is me.\n"
  // // let txt1 = txt
  // // let txt2 = txt
  // // let txt3 = txt
  // let _ = print(txt)
  // let _ = print(txt)
  // let _ = print(txt)
  // // let foo: tau = magic syscall(1, tau)

  // let real-text = !txt

  // let a = real-text
  // let a = real-text
  // let a = real-text
  // let b: i64 = add-i64(3, admit)
  // let a = real-text
  // let a = real-text

  // let _ on a = print(a)

  // let _ = print("hello, world!")

  // // let _ on txt2 = this.text.write(txt2)
  // // let arr-vec = vector-new([arr, arr])
  10
}
