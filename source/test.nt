import {
  this.bool {True},
  this.foreign {THREAD_COND_SIZE, THREAD_MUTEX_SIZE},
  this.int.entity {as-entity-N},
  this.int.show {%ld},
  this.list {for, list},
  this.list.entity,
  this.rune.show {as-show},
  this.text {drop, intercalate-N, pack, reverse, unpack},
  this.text.io {printf},
  this.text.show,
  this.unit {Unit, unit},
  this.word,
}

constant list-int-eq-ops: this.list.entity.trope(int) {
  this.list.entity.from-entity(as-entity-N)
}

constant my-bool: tau {
  this.bool.bool
}

define make-bool(): my-bool {
  True
}

constant some-int-list: list(int) {
  [1, 2, 3]
}

define increment(x: int): int {
  add-int(x, 1)
}

define zen(): unit {
  // printf("SEEK_END: {}\n", [%ld(SEEK_END)]);
  // let xs: list(int) = [1, 2, 3, 4, 3, 2, 1, 2] in
  // let xs' on xs = list-int-eq-ops::nub(xs) in
  // let len on xs' = length(xs') in
  // printf("nub len: {}\n", [%ld(len)]);
  printf("{}\n", [intercalate-N("/", ["foo", "bar", "buzubaoeu„ÅÇ„Åà„Åä„ÅÜte"])]);
  printf("thread mutex size: {}\n", [%ld(THREAD_MUTEX_SIZE)]);
  printf("thread cond size: {}\n", [%ld(THREAD_COND_SIZE)]);
  printf("word size: {}\n", [%ld(this.word.size)]);
  let my-text = reverse("„ÅÇ„ÅÑ„ÅÜ„Åà„Åä„ÄÇhello, world!") in
  let len on my-text = this.text.length(my-text) in
  let char-seq on my-text = unpack(my-text) in
  let _ = my-text in
  for(char-seq, function (ch) {
    printf("{}", [as-show::show(ch)])
  });
  printf("len: {}\n", [%ld(len)]);
  let char-seq-2 on char-seq = pack(char-seq) in
  let _ = char-seq in
  printf("{}\n", [char-seq-2]);
  let tmp = drop(10, *"„ÅÇ„ÅÑ„ÅÜ„Åàüíå„Åä„Åã„Åç„Åè„Åë„Åì‚≠ê„Åï„Åó„Åô„Åõ\n\\aoeu„Åù„Åü„Å°„Å§„Å¶„Å®") in
  printf("{}\n", [this.text.show.as-show::show(tmp)]);
  // let t2 on tmp = append(tmp, "st") in
  // let b on t1, t2 = eq-text(t1, t2) in
  // use this.bool.show.as-show {show} in
  // // let Show(f) = as-show in
  // printf("{}\n", [show(b)]);
  Unit
}

define main(): unit {
  zen()
}
