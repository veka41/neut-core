import {
  this.bool {True, and, bool},
  this.int.show {%ld},
  this.list {for, list},
  this.process,
  this.rune.show {as-show},
  this.text {drop, pack, reverse, unpack},
  this.text.io {printf},
  this.text.show,
  this.thread,
  this.unit {Unit, unit},
}

constant my-bool: tau {
  this.bool.bool
}

define make-bool(): my-bool {
  True
}

constant some-int-list: list(int) {
  [1, 2, 3]
}

define increment(x: int): int {
  add-int(x, 1)
}

define main(): unit {
  // print-int(this.word.size)
  this.process.zen()
}

define zen(): unit {
  let ゼロ = 0 in
  let 加法 = add-int(ゼロ, 1) in
  let _ = this.process.zen() in
  let foo = detach {tau} in
  let my-text = reverse("あいうえお。hello, world!") in
  let len on my-text = this.text.length(my-text) in
  let char-seq on my-text = unpack(my-text) in
  let _ = my-text in
  for(char-seq, function (ch) {
    printf("{}", [as-show::show(ch)])
  });
  printf("len: {}\n", [%ld(len)]);
  let char-seq-2 on char-seq = pack(char-seq) in
  let _ = char-seq in
  printf("{}\n", [char-seq-2]);
  let tmp = drop(10, *"あいうえ💌おかきくけこ⭐さしすせ\n\\aoeuそたちつてと") in
  printf("{}\n", [this.text.show.as-show::show(tmp)]);
  // let t2 on tmp = append(tmp, "st") in
  // let b on t1, t2 = eq-text(t1, t2) in
  // use this.bool.show.as-show {show} in
  // // let Show(f) = as-show in
  // printf("{}\n", [show(b)]);
  Unit
}

define wifexited(x: int): bool {
  introspect os {
  | darwin =>
    let foo = and-int(x, 0b_0111_1111) in
    eq-int(foo, 0)
  }
}

define wifsignaled(x: int): bool {
  introspect os {
  | darwin =>
    let foo = and-int(x, 0b_0111_1111) in
    let b1 = ne-int(foo, 0b_0111_1111) in
    let b2 = ne-int(foo, 0) in
    and(b1, b2)
  }
}
