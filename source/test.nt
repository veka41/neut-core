import {
- this.bool
- this.cell
- this.channel [channel, new-channel, send, receive]
- this.control [loop]
- this.except [Pass, Fail]
- this.errno [Errno]
- this.file [open, close]
- this.function
- this.float [as-semiring, as-ring, as-ring-opaque]
- this.int [as-monoid, as-loset]
- this.int8-array
- this.loset [loset]
- this.list [list, map, minimum, maximum, reverse, sum]
- this.pair
- this.ring [Ring]
- this.random [random]
- this.thread
- this.system
- this.text [text]
- this.unit [unit, Unit]
- this.void
- dict [dict, size, empty, insert, lookup, dict-trope, Dict-Trope, fromLoset]
- FD
- FF
- FM
- L
- Q
- ext
- f
- fa
- magic
- tio
- vector [vector, zip-with]
}

constant L: loset(int) {
  as-loset
}

define L-insert(k: int, v: int, acc: dict(int, int)): dict(int, int) {
  insert(L)(k, v, acc)
}

constant ins {
  @insert(int, int, L)
}

constant int-dict-trope: dict-trope(int, int) {
  fromLoset(L)
}

define make-big-dict(): dict(int, int) {
  let dict.Dict-Trope of {insert} = int-dict-trope in
  // let x = Unit in
  // let item = x: unit in
  loop(700000, empty(), (acc, _) => {
    let key = random(1000000) in
    let val = random(1000000) in
    insert(key, val, acc)
  })
}

define random-lookup-sum(d: &dict(int, int)): unit {
  let Dict-Trope of {lookup} = int-dict-trope in
  let rsum =
    loop(700000, 0, (acc, _) => {
      let key = random(1000000) in
      let val on key =
        match lookup(key, d) {
        - Fail(_) => 0
        - Pass(v) => *v
        }
      in
      let _ = key in
      add-int(acc, val)
    })
  in
  tio.print-int(rsum)
}

// define random-insert(d: dict(int, int)): dict(int, int) {
//   let dict.Dict of { insert } = fromLoset(as-loset) in // hel
//   let xs = L.repeat(100000, (_) => {random(10000)}) in
//   L.fold-left(d, xs, (acc, x) => {
//     let val = random(10000) in
//     insert(x, val, acc)
//   })
// }

define main(): unit {
  // let Ring of { mul } = as-ring-opaque() in
  // let v1 = fact(5) in
  // let v2 = mul(1.2, 3.4) in
  // tio.print-float(add-float(v1, v2));
  // let val2 = add-float(1, 2) in
  // tio.print-float(val2);
  // let Unit = Unit in
  // let OverRing(a, b, c, d, e, f, g) = m.fromRing(this.float.as-ring) in
  // let OverRing of { mk, mul } = m.fromRing(this.float.as-ring) in
  // let m.OverRing of { mk, mul } = m.fromRing(this.int.as-ring) in
  // let mat1 = mk(
  //   [[1, 2, 3],
  //    [4, 5, 6]]
  //   )
  // in
  // let mat2 = mk(
  //   [[1, 2],
  //    [3, 4],
  //    [5, 6]]
  //   )
  // in
  // let mat3 on mat1, mat2 = mul(mat1, mat2) in
  // let _ on mat3 = m.print-mat(tio.print-int, mat3) in
  // let _ = mat1 in
  // let _ = mat2 in
  // let item = ?tau in
  // let k = [tau,       tau] in
  // let v = "test" in
  // let w = tau :: k in
  // let foo = detach { Unit } in
  // let _ = mat3 in

  // let OverRing of { mk, mul } = m.fromRing(this.float.as-ring) in
  // let mat1 = mk(
  //   [[1.3, 2, 3.8],
  //    [4, 5.2, 6]]
  //   )
  // in
  // let mat2 = mk(
  //   [[1, 2],
  //    [3, 4],
  //    [5, 6]]
  //   )
  // in
  // let mat3 on mat1, mat2 = mul(mat1, mat2) in
  // let _ on mat3 = m.print-mat(tio.print-float, mat3) in
  // let _ = mat1 in
  // let _ = mat2 in
  // let _ = mat3 in

  // let OverRing of { mk, mul } = m.fromRing(this.float.as-ring) in

  // let dict.Dict of { empty, insert, lookup, delete } = fromLoset(as-loset) in // hel
  let big-dict = make-big-dict() in
  idealize big-dict {
    random-lookup-sum(big-dict)
  };
  // let _ on bigDict = random-lookup-sum(bigDict) in
  // let _ = bigDict in

  // let bigDict = random-insert(bigDict) in
  // let bigDict = random-insert(bigDict) in
  // let bigDict = random-insert(bigDict) in
  // let k = 10 in
  // let _ on bigDict, k =
  //   let val = lookup(L)(k, bigDict) in
  //   match val {
  //   - Fail(_) =>
  //     tio.print("found nothing\n")
  //   - Pass(val) =>
  //     tio.print-int(*val)
  //   }
  // in

  // let d: dict(int, &text) = empty in
  // // let d: dict(int, &text) = dict.empty() in
  // let d = insert(10, "hello\n", d) in
  // let d = insert(20, "this\n", d) in
  // let d = insert(30, "yo\n", d) in
  // let key = 10 in
  // let _ on d, key =
  //   let val = lookup(key, d) in
  //   match val {
  //   - Fail(_) =>
  //     tio.print("found nothing\n")
  //   - Pass(val) =>
  //     tio.print(*val)
  //   }
  // in // comment. this is me.
  // let d = delete(key, d) in
  // let key = 10 in
  // let _ on d, key =
  //   let val = lookup(key, d) in
  //   match val {
  //   - Fail(_) =>
  //     tio.print("found nothing\n")
  //   - Pass(val) =>
  //     tio.print(*val)
  //   }
  // in
  // tio.print("hey");


  // let val = sum(as-monoid, [1, 2, 3]) in
  // tio.print-int(val);
  // let f = open("test", FF.for-r(), FM.default-file-mode()) in
  // match f {
  // - Fail(Errno(num)) =>
  //   tio.print("fail: ");
  //   tio.print-int(num);
  //   tio.print("\n")
  // - Pass(_) =>
  //   Unit
  // };
  // let g = close(magic.cast(int, _, 30)) in
  // match g {
  // - Fail(Errno(num)) =>
  //   tio.print("fail: ");
  //   tio.print-int(num);
  //   tio.print("\n")
  // - Pass(_) =>
  //   Unit
  // };

  // let _ on mat1 = m.print-mat(tio.print-int, mat1) in
  // tio.print("\n");
  // tio.print("row-size: ");
  // let row-size on mat = m.get-row-size(mat) in
  // tio.print-int(row-size);
  // tio.print("\n");
  // tio.print("col-size: ");
  // let col-size on mat = m.get-col-size(mat) in
  // tio.print-int(col-size);
  // tio.print("\n");
  // let val on mat = m.access(mat, 2, 1) in
  // tio.print-int(val);
  // let v: vector(int) = vector.new([1, 2, 3, 4]) in
  // let _ on v =
  //   vector.for-each(v, (x) => {
  //     // tio.print("hello ");
  //     tio.print-int(x)
  //     // tio.print("\n")
  //   })
  // in
  // // let _ on v = vector.swap(v, 1, 2) in
  // // let _ on v = vector.next(v) in
  // // let _ on v =
  // //   vector.for-each(v, (x) => {
  // //     tio.print("hello ");
  // //     tio.print-int(x);
  // //     tio.print("\n")
  // //   })
  // // in
  // let newvec on v =
  //   vector.for(v, (x) => {
  //     add-int(x, 10)
  //   })
  // in
  // let vec3 on v, newvec = zip-with(add-int, v, newvec) in
  // let _ on vec3 =
  //   vector.for-each(vec3, (x) => {
  //     tio.print("hello ");
  //     tio.print-int(x);
  //     tio.print("\n")
  //   })
  // in
  // let _ = v in
  Unit
  // let mat =
  //   m.new([
  //     [1, 2.812374, 3],
  //     [4, 5, 6]
  //   ])
  // in
  // let mat2 =
  //   m.new([
  //     [31.2, 2.812, 8],
  //     [-1234, -5, 23]
  //   ])
  // in
  // let sum-mat on mat, mat2 = m.add-mat(mat, mat2) in
  // let _ on sum-mat = m.print-mat(sum-mat) in
  // Unit
}
