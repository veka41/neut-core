import {
- this.bool
- this.void
- this.function
- this.i8-array
- this.list
- this.both
- this.option
- this.either
- this.system
- this.text
- this.unit
- this.vector
- this.file
- this.file.flag => FF
- this.file.mode => FM
- this.file.descriptor => FD
- this.text.io => text
- this.queue => Q
- this.external => ext
- this.thread => t
- this.channel
- this.cell
- this.magic => magic
}

variant item {
- Bar(int)
}

define show-texts(xs: list(text)): unit {
  match xs {
  - [] =>
    Unit
  - t :< ts =>
    let _ on t = text.print(t)
    let _ = t
    text.print("\n")
    show-texts(ts)
  }
}

variant my-list(a: tau) {
- Nil()
- Cons(my-list(a))
}

define sample[a, b](x: either(a, b)): either(a, b) {
  let+ aoeu = x
  Right(aoeu)
}

define main(): unit {
  // let item: this.queue.queue(tau) = this.queue.empty()
  // let _ = item

  // let xs: my-list(int) = this.test.Nil()
  // let xs-cell = new-cell(xs)
  // let _ = xs-cell
  // test
  // test
  //
  // test args
  //
  // let argc = get-argc()
  // text.print-int(argc)
  // text.print("\n")
  // let argv = get-argv()
  // text.print("arguments:\n")
  let a: either(tau, tau) = Left(tau)
  let b: both(tau, int) = Both(tau, 10)
  // show-texts(argv)
  let f1: flow(tau) =
    detach {
      tau
    }

  // let c = new-cell([10]): cell(list(int))
  // let _ on c = {
  //   mutate(c, lambda (xs) {1 :< xs})
  //   mutate(c, lambda (xs) {2 :< xs})
  //   mutate(c, lambda (xs) {3 :< xs})
  //   borrow(c, lambda (xs) {
  //     text.print("value: ")
  //     text.print-int(this.list.length(xs))
  //     text.print("\n")
  //   })
  //   // mutate(c, lambda (_) {clone(c)})
  // }
  // let _ = c


  // channel test
  // t.raw-test()
  // let ch-orig = t.new-channel()
  // text.print("created a channel\n")
  // t.test-lock(ch-orig)

  // let ch = new-channel(() -> int)
  // let ch: channel(() -> int) = ch
  // let ch-clone = ch
  // text.print("created a channel\n")
  // let _ on ch = send(ch, lambda () {1})
  // let ch = ch
  // let ch-clone = ch
  // let _ on ch-clone = send(ch-clone, lambda () {1})
  // let tmp on ch-clone = {
  //   let f =
  //     detach {
  //       text.print("I'm the thread that does downloading...\n")
  //       ext.sleep(4)
  //               text.print("sending from another thread\n")
  //       send(ch-clone, lambda () {3})
  //       text.print("done\n")
  //     }
  //   let g =
  //     detach {
  //       ext.sleep(1)
  //       text.print("sending from another thread (GGG)\n")
  //       send(ch-clone, lambda () {4})
  //       text.print("done\n")
  //     }
  //   let v1 = receive(ch-clone)
  //   let v2 = receive(ch-clone)
  //   let v3 = receive(ch-clone)

  //   text.print("i'm just waiting\n")
  //   // let v4 = t.receive-from-channel(magic.cast(int, t.channel-internal(() -> int), ch))

  //   // let result = add-int(v1(), add-int(v2(), add-int(v3(), v4())))

  //   attach f
  //   attach g
  // }
  // let _ = ch



    // t.send-to-channel(lambda () {1}, magic.cast(int, t.channel-internal(() -> int), ch))
    // t.send-to-channel(lambda () {2}, magic.cast(int, t.channel-internal(() -> int), ch))
    // let f =
    //   detach {
    //     text.print("I'm the thread that does downloading...\n")
    //     ext.sleep(2)
    //     text.print("sending from another thread\n")
    //     t.send-to-channel(lambda () {3}, magic.cast(int, t.channel-internal(() -> int), ch))
    //     text.print("done\n")
    //   }
    // let g =
    //   detach {
    //     ext.sleep(3)
    //     text.print("sending from another thread (GGG)\n")
    //     t.send-to-channel(lambda () {4}, magic.cast(int, t.channel-internal(() -> int), ch))
    //     text.print("done\n")
    //   }
    // let v1 = t.receive-from-channel(magic.cast(int, t.channel-internal(() -> int), ch))
    // let v2 = t.receive-from-channel(magic.cast(int, t.channel-internal(() -> int), ch))
    // let v3 = t.receive-from-channel(magic.cast(int, t.channel-internal(() -> int), ch))
    // // let v4 = t.receive-from-channel(magic.cast(int, t.channel-internal(() -> int), ch))

    // // let result = add-int(v1(), add-int(v2(), add-int(v3(), v4())))

    // attach f
    // attach g



  // text.print("hello, got the result: ")
  // text.print-int(result)
  // text.print("\n")

  // t.discard-channel(magic.cast(int, t.channel-internal(int), ch))


  // let q: Q.queue(int) = Q.empty()
  // let q = Q.enqueue(1, q)
  // let q = Q.enqueue(2, q)
  // let q = Q.enqueue(3, q)
  // match Q.dequeue(q) {
  // - None =>
  //   Unit
  // - Some(tuple(v, rest)) =>
  //   text.print("the first element: ")
  //   text.print-int(v)
  //   text.print("\n")
  //   Unit
  // }

  // text.print("thread testing.\n")
  // let some-text = "hello, world!\n"
  // let f1: flow(() -> int)  =
  //   detach {
  //     ext.sleep(3)
  //     text.print("I'm flow 1.\n")
  //     text.print(some-text)
  //     lambda () { 20: int }
  //   }
  // // let flow1-copy = flow1
  // // // let _ = eq-int(flow1-copy, tau)
  // // let flow1-copy = flow1
  // let flow2 =
  //   detach {
  //     ext.sleep(2)
  //     text.print("I'm flow 2\n")
  //     text.print(some-text)
  //     2: int
  //   }
  // let longer-flow =
  //   detach {
  //     let value = attach flow2
  //     text.print("I'm the continuation of flow 2\n")
  //     text.print(some-text)
  //     add-int(value, 10)
  //   }
  // let p3 =
  //   detach {
  //     ext.sleep(1)
  //     text.print("I'm flow 3\n")
  //     text.print(some-text)
  //     3: int
  //   }
  // text.print("spawned three flows. awaiting...\n")
  // let v1 = attach f1
  // let v3 = attach p3
  // let v2 = attach longer-flow
  // text.print("done. results: \n")
  // // let Bar(result) = v1
  // // text.print-int(result)
  // // text.print-int(v1())
  // text.print-int(v1())
  // text.print("\n")
  // text.print-int(v2)
  // text.print("\n")
  // text.print-int(v3)
  // text.print("\n")


  // text.print("input> ")
  // let input-or-none = text.get-line()
  // let _ = input-or-none
  // let _ = input-or-none
  // let _ = input-or-none
  // let _ = input-or-none
  // let copy = input-or-none
  // match copy {
  // - None =>
  //   text.print-line("couldn't get from input")
  // - Some(input) =>
  //   text.print-line("result:")
  //   ext.sleep(3)
  //   let _ on input = text.print-line(input)
  //   let _ = input
  //   Unit
  // }

  // let file = open("./sample6", FF.for-rw-append(), FM.default-file-mode())
  // let _ = text.write("hello, world!\n", file)
  // close(file)

  // let file = open("./sample6", FF.for-r(), FM.default-file-mode())
  // let content = text.read(file)
  // text.print("result:\n")
  // match content {
  // - None =>
  //   text.print("couldn't read the file\n")
  // - Some(content) =>
  //   let _ on content = text.print(content)
  //   let _ = content
  //   close(file)
  // }

  // print("\n")

  // let input = read(FD.stdin(), 800)

  // print("user input:\n")

  // let _ on input = print(input)

  // let size = shl-int(2, 8)
  // print-int(size)

  // let str1 = "hello, "
  // let str2 = "world!"
  // // let txt = !"hello, world"
  // // let a = txt
  // // let a = txt
  // // let a = txt
  // // print-line("hello, world!\n")
  // let text-from-int = from-int(-9874123849123749)
  // let _ on text-from-int = print-line(text-from-int)
  // // print-int(1234)
  // // print-line(str1)
  // // print-line(str2)
  // let str = this.text.append(str1, str2)
  // let _ on str = {
  //   print-line("↓↓↓")
  //   print-line(str)
  //   print-line("↑↑↑")
  // }
  // let empty = empty()
  // match naive-tail(empty) {
  // - None =>
  //   print-line("nothing")
  // - Some(new-str) =>
  //   let _ on new-str = print-line(new-str)
  //   let a = new-str
  //   let a = new-str
  //   let a = new-str
  //   let a = new-str
  //   print-line("done")
  // }

  // let xs = ["foo", "bar", "buz"]
  // let sample on xs = intercalate(", ", xs)
  // let _ on sample = print-line(sample)

  // print-character(48)
  // print-line("print-int: ")
  // print-int(-4218934)
  // print-line("here")
  // let xs = [104, 101, 108, 108, 111, 10]
  // let arr = i8-array-new(xs)
  // let vec = vector-new(xs)
  // let v1 on arr = i8-array-access(arr, 2)
  // let v0 on vec = vector-access(vec, 2)
  // let a = vec
  // let b = vec
  // let txt = "hello, world! this is me.\n"
  // // let txt1 = txt
  // // let txt2 = txt
  // // let txt3 = txt
  // let _ = print(txt)
  // let _ = print(txt)
  // let _ = print(txt)
  // // let foo: tau = magic syscall(1, tau)

  // let real-text = !txt

  // let a = real-text
  // let a = real-text
  // let a = real-text
  // let b: int = add-int(3, admit)
  // let a = real-text
  // let a = real-text

  // let _ on a = print(a)

  // let _ = print("hello, world!")

  // // let _ on txt2 = this.text.write(txt2)
  // // let arr-vec = vector-new([arr, arr])
  Unit
}
