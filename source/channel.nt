import {
- this.bool
- this.option
- this.top
- this.text
- this.text.io => io
- this.memory => mem
- this.magic => magic
- this.product
- this.external => ext
- this.queue => Q
}

export {
- channel
- new-channel
- send
- receive
}

resource channel-internal {
- lambda (ch: i64) {
    let a = magic.cast(i64, tau, mem.load-i64(add-i64(ch, 120)))
    ext.thread-cond-destroy(add-i64(ch, 72))
    ext.thread-mutex-destroy(add-i64(ch, 8))
    let _: Q.queue(a) = magic cast(i64, Q.queue(a), mem.load-i64(ch))
    ext.free(ch)
    0
  }
- lambda (ch: i64)  {
    let a = magic.cast(i64, tau, mem.load-i64(add-i64(ch, 120)))
    let q: &Q.queue(a) = magic.cast(i64, &Q.queue(a), mem.load-i64(ch))
    let q-clone: Q.queue(a) = get-clone(Q.queue(a), q)
    magic.cast(channel(a), i64, new-channel-internal(a, q-clone))
  }
}

define-inline get-clone(a: tau, x: &a): a {
  !x
}

// (queue, mutex, cond)
define channel(_: tau): tau {
  channel-internal
}

define new-channel(a: tau): channel(a) {
  new-channel-internal(a, Q.empty())
}

define new-channel-internal(a: tau, q: Q.queue(a)): channel(a) {
  let ptr = ext.malloc(128) // 8 + 64 + 48 + 8 (FIXME: remove this hardcoded value)
  mem.store-i64(ptr, magic.cast(Q.queue(a), i64, q))
  ext.thread-mutex-init(add-i64(ptr, 8))
  ext.thread-cond-init(add-i64(ptr, 72))
  mem.store-i64(add-i64(ptr, 120), magic.cast(tau, i64, a))
  magic.cast(i64, channel(a), ptr)
}

define send[a](ch: &channel(a), x: a): top {
  let ch = magic.cast(&channel(a), i64, ch)
  let mutex-ptr = add-i64(ch, 8)
  ext.thread-mutex-lock(mutex-ptr)
  let q-base: i64 = mem.load-i64(ch)
  let q: Q.queue(a) = magic.cast(i64, Q.queue(a), q-base)
  let q = Q.enqueue(x, q)
  mem.store-i64(ch, magic.cast(Q.queue(a), i64, q))
  ext.thread-cond-signal(add-i64(ch, 72))
  ext.thread-mutex-unlock(mutex-ptr)
  Unit
}

define receive[a](ch: &channel(a)): a {
  let ch = magic.cast(&channel(a), i64, ch)
  let mutex-ptr = add-i64(ch, 8)
  ext.thread-mutex-lock(mutex-ptr)
  receive-from-channel-inner(ch, mutex-ptr)
}

define receive-from-channel-inner[a](ch: i64, mutex-ptr: i64): a {
  let q: Q.queue(a) = magic.cast(i64, Q.queue(a), mem.load-i64(ch))
  match Q.dequeue(q) {
  - Some(tuple(v, q)) =>
    mem.store-i64(ch, magic.cast(Q.queue(a), i64, q))
    ext.thread-mutex-unlock(mutex-ptr)
    v
  - None =>
    mem.store-i64(ch, magic.cast(Q.queue(i64), i64, Q.empty()))
    let cond-ptr = add-i64(ch, 72)
    ext.thread-cond-wait(cond-ptr, mutex-ptr)
    receive-from-channel-inner(ch, mutex-ptr)
  }
}
