import {
- this.either
- this.unit [unit]
- this.int [sum-int]
- this.list => list
- this.arch => arch
- this.memory => mem
- this.magic => magic
- this.both
- this.external => ext
- this.queue => Q
}

resource channel-internal {
- (ch: int) => {
    let u = arch.unit() in
    let mutex-size = ext.thread-mutex-size() in
    let cond-size = ext.thread-cond-size() in
    let cond-offset = add-int(u, mutex-size) in
    let type-offset = add-int(u, add-int(mutex-size, cond-size)) in
    let a = magic.cast(int, tau, mem.load-int(add-int(ch, type-offset))) in
    ext.thread-cond-destroy(add-int(ch, cond-offset));
    ext.thread-mutex-destroy(add-int(ch, u));
    let _: Q.queue(a) = magic cast(int, Q.queue(a), mem.load-int(ch)) in
    ext.free(ch);
    0
  }
- (ch: int) => {
    let u = arch.unit() in
    let mutex-size = ext.thread-mutex-size() in
    let cond-size = ext.thread-cond-size() in
    let type-offset = add-int(u, add-int(mutex-size, cond-size)) in
    let a = magic.cast(int, tau, mem.load-int(add-int(ch, type-offset))) in
    let q: *Q.queue(a) = magic.cast(int, *Q.queue(a), mem.load-int(ch)) in
    let q-clone: Q.queue(a) = get-clone(Q.queue(a), q) in
    magic.cast(channel(a), int, new-channel-internal(a, q-clone))
  }
}

inline get-clone(a: tau, x: *a): a {
  !x
}

// (queue, mutex, cond, queue-elem-type)
define channel(_: tau): tau {
  channel-internal
}

define new-channel(a: tau): channel(a) {
  new-channel-internal(a, Q.empty(a))
}

define new-channel-internal(a: tau, q: Q.queue(a)): channel(a) {
  let mutex-size = ext.thread-mutex-size() in
  let cond-size = ext.thread-cond-size() in
  let u = arch.unit() in
  let ptr = ext.malloc(sum-int([u, mutex-size, cond-size, u])) in
  mem.store-int(magic.cast(Q.queue(a), int, q), ptr);
  ext.thread-mutex-init(add-int(ptr, u));
  ext.thread-cond-init(add-int(ptr, add-int(u, mutex-size)));
  mem.store-int(magic.cast(tau, int, a), add-int(ptr, add-int(u, add-int(mutex-size, cond-size))));
  magic.cast(int, channel(a), ptr)
}

define send(a: tau, ch: *channel(a), x: a): unit {
  let ch = magic.cast(*channel(a), int, ch) in
  let u = arch.unit() in
  let mutex-ptr = add-int(ch, u) in
  ext.thread-mutex-lock(mutex-ptr);
  let q-base: int = mem.load-int(ch) in
  let q: Q.queue(a) = magic.cast(int, Q.queue(a), q-base) in
  let q = Q.enqueue(a, x, q) in
  mem.store-int(magic.cast(Q.queue(a), int, q), ch);
  let mutex-size = ext.thread-mutex-size() in
  ext.thread-cond-signal(add-int(ch, add-int(u, mutex-size)));
  ext.thread-mutex-unlock(mutex-ptr)
}

define receive(a: tau, ch: *channel(a)): a {
  let ch = magic.cast(*channel(a), int, ch) in
  let u = arch.unit() in
  let mutex-ptr = add-int(ch, u) in
  ext.thread-mutex-lock(mutex-ptr);
  receive-from-channel-inner(a, ch, mutex-ptr)
}

define receive-from-channel-inner(a: tau, ch: int, mutex-ptr: int): a {
  let q: Q.queue(a) = magic.cast(int, Q.queue(a), mem.load-int(ch)) in
  match Q.dequeue(a, q) {
  - Some(Tuple(v, q)) =>
    mem.store-int(magic.cast(Q.queue(a), int, q), ch);
    ext.thread-mutex-unlock(mutex-ptr);
    v
  - None =>
    mem.store-int(magic.cast(Q.queue(int), int, Q.empty(int)), ch);
    let u = arch.unit() in
    let mutex-size = ext.thread-mutex-size() in
    let cond-ptr = add-int(ch, add-int(u, mutex-size)) in
    ext.thread-cond-wait(cond-ptr, mutex-ptr);
    receive-from-channel-inner(a, ch, mutex-ptr)
  }
}
