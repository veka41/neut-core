import {
- this.bool
- this.list [list]
- this.ordering [GT, LT, EQ]
- this.ring [ring, Ring]
- this.rig [rig, from-ring]
- e
- ordered [ordered, Ordered]
}

inline as-ordered(): ordered.ordered(int) {
  Ordered of {
  - identity => eq-int
  - order =>
    (x, y) => {
      if gt-int(x, y) {
        GT
      } else-if lt-int(x, y) {
        LT
      } else {
        EQ
      }
    }
  }
}

inline as-entity(): e.entity(int) {
  e.from-ordered(as-ordered())
}

define sum-int(xs: list(int)): int {
  let f =
    mu loop(ys: list(int), acc: int): int {
      match ys {
      - [] =>
        acc
      - z :: zs =>
        loop(zs, add-int(z, acc))
      }
    }
  in
  f(xs, 0)
}

inline as-ring(): ring(int) {
  Ring of {
  - zero => 0
  - add => add-int
  - sub => sub-int
  - one => 1
  - mul => mul-int
  }
}

inline as-rig(): rig(int) {
  from-ring(as-ring())
}
