/// list.nt

import {
- this.bool
- this.both
- this.either
- this.function
}

export {
- list {..}
- reverse
- length
- append
- fold-left
- fold-right
- map
- for
- concat
- unzip
- uncons
- all
- any
- range
- filter-some
}

variant list(a: tau) {
- Nil
- Cons(a, list(a))
}

define fold-left[a, b](f: (b, a) -> b, acc: b, xs: list(a)): b {
  match xs {
  - [] =>
    acc
  - y :: ys =>
    fold-left(f, f(acc, y), ys)
  }
}

define fold-right[a, b](f: (a, b) -> b, acc: b, xs: list(a)): b {
  match xs {
  - [] =>
    acc
  - y :: ys =>
    f(y, fold-right(f, acc, ys))
  }
}

define-inline map[a, b](f: a -> b, xs: list(a)): list(b) {
  map-internal(f)(xs)
}

define-inline for[a, b](xs: list(a), f: a -> b): list(b) {
  map-internal(f)(xs)
}

define-inline map-internal[a, b](f: a -> b): list(a) -> list(b) {
  mu loop(xs) {
    match xs {
    - [] =>
      []
    - y :: ys =>
      f(y) :: loop(ys)
    }
  }
}

define append[a](xs: list(a), ys: list(a)): list(a) {
  fold-left(flip(Cons), xs, ys)
}

define concat[a](xss: list(list(a))): list(a) {
  fold-left(append, [], xss)
}

define reverse[a](xs: list(a)): list(a) {
  reverse-helper(xs, [])
}

define reverse-helper[a](xs: list(a), acc: list(a)): list(a) {
  match xs {
  - [] =>
    acc
  - y :: ys =>
    reverse-helper(ys, y :: acc)
  }
}

define length[a](xs: &list(a)): int {
  let length-tailcall =
    mu rec(acc: int, xs: &list(a)): int {
      case xs {
      - [] =>
        acc
      - _ :: ys =>
        rec(add-int(1, acc), ys)
      }
    }
  in
  length-tailcall(0, xs)
}

define unzip[a, b](xs: list(tuple(a, b))): tuple(list(a), list(b)) {
  match xs {
  - [] =>
    Tuple([], [])
  - Tuple(l, r) :: rest =>
    let Tuple(rest-l, rest-r) = unzip(rest) in
    Tuple(l :: rest-l, r :: rest-r)
  }
}

define uncons[a](xs: list(a)): ?tuple(a, list(a)) {
  match xs {
  - [] =>
    None
  - y :: ys =>
    Some(Tuple(y, ys))
  }
}

define all(xs: list(bool)): bool {
  fold-left(and, True, xs)
}

define any(xs: list(bool)): bool {
  fold-left(or, False, xs)
}

// right-open interval
define range(from: int, to: int): list(int) {
  if eq-int(from, to) {
    []
  } else {
    from :: range(add-int(from, 1), to)
  }
}

define filter-some[a](xs: list(option(a))): list(a) {
  match xs {
  - [] =>
    []
  - Some(v) :: rest =>
    v :: filter-some(rest)
  - None :: rest =>
    filter-some(rest)
  }
}
