import {
- this.bool [bool, True, False, and, or]
- this.both
- this.either [option]
- this.function [flip]
- this.data.semigroup [semigroup, Semigroup]
- this.data.monoid [monoid, Monoid]
- this.data.functor [functor, Functor]
- this.data.ordered [ordered, Ordered]
- this.ordering [LT, GT]
- this.unit [unit, Unit]
}

data list(a: tau) {
- Nil
- Cons(a, list(a))
}

define fold-left of {
- elem-type: tau
- result-type: tau
- consumer: (result-type, elem-type) -> result-type
- acc: result-type
- xs: list(elem-type)
}: result-type {
  let loop =
    mu rec(acc: result-type, xs: list(elem-type)) {
      match xs {
      - [] =>
        acc
      - y :: ys =>
        rec(consumer(acc, y), ys)
      }
    }
  in
  loop(acc, xs)
}

define fold-right of {
- elem-type: tau
- result-type: tau
- consumer: (elem-type, result-type) -> result-type
- acc: result-type
- xs: list(elem-type)
}: result-type {
  match xs {
  - [] =>
    acc
  - y :: ys =>
    consumer(y, fold-right(elem-type, result-type, consumer, acc, ys))
  }
}

inline map(a: tau, b: tau, f: a -> b, xs: list(a)): list(b) {
  map-internal(a, b, f)(xs)
}

inline for-each(a: tau, b: tau, xs: list(a), f: a -> b): list(b) {
  map-internal(a, b, f)(xs)
}

inline for(a: tau, xs: list(a), f: a -> unit): unit {
  let _ = map-internal(a, unit, f)(xs) in
  Unit
}

inline map-internal(a: tau, b: tau, f: a -> b): list(a) -> list(b) {
  mu loop(xs) {
    match xs {
    - [] =>
      []
    - y :: ys =>
      Cons(f(y), loop(ys))
    }
  }
}

define map-noetic(a: tau, b: tau, f: *a -> b, xs: *list(a)): list(b) {
  case xs {
  - [] =>
    []
  - y :: ys =>
    f(y) :: map-noetic/2(f, ys)
  }
}

define append(a: tau, xs: list(a), ys: list(a)): list(a) {
  fold-right/2(Cons, ys, xs)
}

define concat(a: tau, xss: list(list(a))): list(a) {
  let partial-append = (xs, ys) => { append(a, xs, ys) } in
  fold-left(list(a), list(a), partial-append, [], xss)
}

define reverse(a: tau, xs: list(a)): list(a) {
  let helper =
    mu rec(xs: list(a), acc: list(a)) {
      match xs {
      - [] =>
        acc
      - y :: ys =>
        rec(ys, y :: acc)
      }
    }
  in
  helper(xs, [])
}

define length(a: tau, xs: *list(a)): int {
  let length-tailcall =
    mu rec(acc: int, xs: *list(a)): int {
      case xs {
      - [] =>
        acc
      - _ :: ys =>
        rec(add-int(1, acc), ys)
      }
    }
  in
  length-tailcall(0, xs)
}

define unzip(a: tau, b: tau, xs: list(tuple(a, b))): tuple(list(a), list(b)) {
  match xs {
  - [] =>
    Tuple([], [])
  - Tuple(l, r) :: rest =>
    let Tuple(rest-l, rest-r) = unzip(a, b, rest) in
    Tuple(l :: rest-l, r :: rest-r)
  }
}

define uncons(a: tau, xs: list(a)): ?tuple(a, list(a)) {
  match xs {
  - [] =>
    None
  - y :: ys =>
    Some(Tuple(y, ys))
  }
}

define all(xs: list(bool)): bool {
  fold-left(bool, bool, and, True, xs)
}

define any(xs: list(bool)): bool {
  fold-left(bool, bool, or, False, xs)
}

// right-open interval
define range(from: int, to: int): list(int) {
  if eq-int(from, to) {
    []
  } else {
    from :: range(add-int(from, 1), to)
  }
}

define filter-some(a: tau, xs: list(option(a))): list(a) {
  match xs {
  - [] =>
    []
  - Some(v) :: rest =>
    v :: filter-some(a, rest)
  - None :: rest =>
    filter-some(a, rest)
  }
}

inline minimum(a: tau, as-ord: ordered(a))(xs: list(a)): ?a {
  let Ordered(..) = as-ord in
  let helper =
    mu self(cand: a, ys: list(a)): a {
      match ys {
      - [] =>
        cand
      - z :: zs =>
        match order(cand, z) {
        - LT =>
          self(cand, zs)
        - _ =>
          self(z, zs)
        }
      }
    }
  in
  match xs {
  - [] =>
    None
  - y :: ys =>
    Some(helper(y, ys))
  }
}

inline maximum(a: tau, as-ord: ordered(a))(xs: list(a)): ?a {
  let Ordered(..) = as-ord in
  let helper =
    mu self(cand: a, ys: list(a)): a {
      match ys {
      - [] =>
        cand
      - z :: zs =>
        match order(cand, z) {
        - GT =>
          self(cand, zs)
        - _ =>
          self(z, zs)
        }
      }
    }
  in
  match xs {
  - [] =>
    None
  - y :: ys =>
    Some(helper(y, ys))
  }
}


inline as-semigroup(a: tau): semigroup(list(a)) {
  Semigroup of {
  - append =>
    (x, y) => {
      append(a, x, y)
    }
  }
}

inline as-monoid(a: tau): monoid(list(a)) {
  Monoid of {
  - as-semigroup =>
    as-semigroup(a)
  - empty =>
    []
  }
}

inline as-functor(): functor(list) {
  Functor of {
  - map =>
    map
  }
}
