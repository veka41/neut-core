import {
- this.bool {bool, True, False, and, or}
- this.except {none, Pass, Fail}
- this.functor {functor, Functor}
- this.monoid {monoid, Monoid}
- this.order {LT, GT}
- this.pair
- this.semigroup {semigroup, from-monoid}
- this.unit {unit, Unit}
- Lo {loset, Loset}
}

data list(a: tau) {
- Nil
- Cons(a, list(a))
}

// folds are optimized into loops
inline fold-left[elem-type, result-type] of {
- acc: result-type
- xs: list(elem-type)
- consumer: (result-type, elem-type) -> result-type
}: result-type {
  let helper =
    mu loop(acc, xs) {
      match xs {
      - [] =>
        acc
      - y :: ys =>
        loop(consumer(acc, y), ys)
      }
    }
  in
  helper(acc, xs)
}

inline fold-left-noetic[elem-type, result-type] of {
- acc: result-type
- xs: &list(elem-type)
- consumer: (result-type, &elem-type) -> result-type
}: result-type {
  let helper =
    mu loop(acc, xs) {
      case xs {
      - [] =>
        acc
      - y :: ys =>
        loop(consumer(acc, y), ys)
      }
    }
  in
  helper(acc, xs)
}

inline fold-right[elem-type, result-type] of {
- xs: list(elem-type)
- acc: result-type
- consumer: (elem-type, result-type) -> result-type
}: result-type {
  let helper =
    mu loop(xs, acc) {
      match xs {
      - [] =>
        acc
      - y :: ys =>
        consumer(y, loop(ys, acc))
      }
    }
  in
  helper(xs, acc)
}

inline fold-right-noetic[elem-type, result-type] of {
- xs: &list(elem-type)
- acc: result-type
- consumer: (&elem-type, result-type) -> result-type
}: result-type {
  let helper =
    mu loop(xs, acc) {
      case xs {
      - [] =>
        acc
      - y :: ys =>
        consumer(y, loop(ys, acc))
      }
    }
  in
  helper(xs, acc)
}

inline map[a, b](f: a -> b, xs: list(a)): list(b) {
  fold-right(xs, [], (x, acc) => {
    f(x) :: acc
  })
}

inline map-noetic[a, b](f: &a -> b, xs: &list(a)): list(b) {
  fold-right-noetic(xs, [], (x, acc) => {
    f(x) :: acc
  })
}

inline for-each[a, b](xs: list(a), f: a -> b): list(b) {
  map(f, xs)
}

inline for[a](xs: list(a), f: a -> unit): unit {
  let _ = map(f, xs) in
  Unit
}

define loop(count: int, f: int -> unit): unit {
  let helper =
    mu self(cursor) {
      if ge-int(cursor, count) {
        Unit
      } else {
        f(cursor);
        self(add-int(cursor, 1))
      }
    }
  in
  helper(0)
}

inline repeat[a](count: int, f: int -> a): list(a) {
  let helper =
    mu self(cursor) {
      if ge-int(cursor, count) {
        []
      } else {
        f(cursor) :: self(add-int(cursor, 1))
      }
    }
  in
  helper(0)
}

define append[a](xs: list(a), ys: list(a)): list(a) {
  fold-right(xs, ys, (x, acc) => {
    Cons(x, acc)
  })
}

define concat[a](xss: list(list(a))): list(a) {
  fold-left([], xss, (acc, xs) => {
    append(acc, xs)
  })
}

define reverse[a](xs: list(a)): list(a) {
  fold-left([], xs, (acc, x) => {
    x :: acc
  })
}

define length[a](xs: &list(a)): int {
  fold-left-noetic(0, xs, (acc, _) => {
    add-int(1, acc)
  })
}

define unzip[a, b](xs: list(tuple(a, b))): tuple(list(a), list(b)) {
  fold-right(xs, Tuple([], []), (x, acc) => {
    let Tuple(l, r) = x in
    let Tuple(rest-l, rest-r) = acc in
    Tuple(l :: rest-l, r :: rest-r)
  })
}

define uncons[a](xs: list(a)): ?tuple(a, list(a)) {
  match xs {
  - [] =>
    none()
  - y :: ys =>
    Pass(Tuple(y, ys))
  }
}

define all(xs: list(bool)): bool {
  fold-left(True, xs, and)
}

define any(xs: list(bool)): bool {
  fold-left(False, xs, or)
}

// right-open interval
define range(from: int, to: int): list(int) {
  if eq-int(from, to) {
    []
  } else {
    from :: range(add-int(from, 1), to)
  }
}

define filter-some[a](xs: list(?a)): list(a) {
  fold-right(xs, [], (x, acc) => {
    match x {
    - Pass(v) =>
      v :: acc
    - Fail(_) =>
      acc
    }
  })
}

inline sum[a](as-monoid: monoid(a), xs: list(a)): a {
  let Monoid of { e, op } = as-monoid in
  fold-left(e, xs, (acc, x) => { op(acc, x) })
}

inline minimum[a](as-ord: loset(a)): list(a) -> ?a {
  (xs) => {
    let Loset of { cmp } = as-ord in
    match xs {
    - [] =>
      none()
    - y :: ys =>
      Pass(fold-left(y, ys, (acc, y) => {
        let order on acc, y = cmp(acc, y) in
        match order {
        - LT =>
          acc
        - _ =>
          y
        }
      }))
    }
  }
}

inline maximum[a](as-ord: loset(a)): list(a) -> ?a {
  (xs) => {
    let Loset of { cmp } = as-ord in
    let helper =
      mu self(cand: a, ys: list(a)): a {
        match ys {
        - [] =>
          cand
        - z :: zs =>
          let order on cand, z = cmp(cand, z) in
          match order {
          - GT =>
            self(cand, zs)
          - _ =>
            self(z, zs)
          }
        }
      }
    in
    match xs {
    - [] =>
      none()
    - y :: ys =>
      Pass(helper(y, ys))
    }
  }
}

inline as-monoid[a](): monoid(list(a)) {
  Monoid of {
  - e =
    []
  - op =
    (x, y) => {
      append(x, y)
    }
  }
}

inline as-semigroup[a](): semigroup(list(a)) {
  from-monoid(as-monoid())
}

constant as-functor: functor(list) {
  Functor of {
  - map =
    (_, _, f, xs) => { map(f, xs) }
  }
}
