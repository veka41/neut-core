import {
- this.bool
- this.list
- this.top
}

export {
- i8-array
- i8-array-new
- i8-array-access
}

define copy-i8-array(source-pointer: i64, target-pointer: i64, index: i64, from: i64, to: i64): top {
  if eq-i64(from, to) {
    Unit
  } else {
    let value: i8 = magic load(i8, add-i64(source-pointer, from))
    let _: i64 = magic store(i8, add-i64(target-pointer, index), value)
    copy-i8-array(source-pointer, target-pointer, add-i64(index, 1), add-i64(from, 1), to)
  }
}

resource i8-array {
- lambda(x: i64) {
    magic external(free, x)
  }
- lambda(source-pointer: i64) {
    let from: i64 = magic load(i64, source-pointer)
    let to: i64 = magic load(i64, add-i64(source-pointer, 8))
    let length = sub-i64(to, from)
    let target-pointer = magic external(malloc, add-i64(length, 16))
    let _: i64 = magic store(i64, target-pointer, 0: i64)
    let _: i64 = magic store(i64, add-i64(target-pointer, 8), length)
    let _ = copy-i8-array(add-i64(source-pointer, 16), add-i64(target-pointer, 16), 0, from, to)
    target-pointer
  }
}

define i8-array-new(xs: list(i8)): i8-array {
  let len on xs = length(xs)
  let base-pointer = magic external(malloc, add-i64(len, 16))
  let _: i64 = magic store(i64, base-pointer, 0: i64)
  let _: i64 = magic store(i64, add-i64(base-pointer, 8), len)
  let content-pointer: i64 = add-i64(base-pointer, 16)
  let store-values =
    define self(values: list(i8), index: i64): top {
      match values {
      - [] =>
        Unit
      - v :< rest =>
        let _: i64 = magic store(i8, add-i64(content-pointer, index), v)
        self(rest, add-i64(index, 1))
      }
    }
  let _ = store-values(xs, 0)
  magic cast(i64, i8-array, base-pointer)
}

define-inline i8-array-access(xs: &i8-array, i: i64): i8 {
  let ptr = magic cast(&i8-array, i64, xs)
  magic load(i8, add-i64(add-i64(ptr, 16), i))
}
