import {
- this.bool
- this.list
- this.top
}

export {
- i8-array
- i8-array-new
- i8-array-access
}

define copy-i8-array(source-pointer: i64, target-pointer: i64, counter: i64, length: i64): top {
  if eq-i64(counter, length) {
    Unit
  } else {
    let value-pointer = add-i64(source-pointer, counter)
    let value: i8 = magic load(i8, value-pointer)
    let target-value-pointer = add-i64(target-pointer, counter)
    let _: i64 = magic store(i8, target-value-pointer, value)
    copy-i8-array(source-pointer, target-pointer, add-i64(counter, 1), length)
  }
}

resource i8-array {
- lambda(x: i64) {
    magic external(free, x)
  }
- lambda(source-pointer: i64) {
    let length: i64 = magic load(i64, source-pointer)
    let target-pointer = magic external(malloc, add-i64(length, 8))
    let _: i64 = magic store(i64, target-pointer, length)
    let _ = copy-i8-array(add-i64(source-pointer, 8), add-i64(target-pointer, 8), 0, length)
    target-pointer
  }
}

define i8-array-new(xs: list(i8)): i8-array {
  let len on xs = length(xs)
  let base-pointer = magic external(malloc, add-i64(len, 8))
  let _: i64 = magic store(i64, base-pointer, len)
  let content-pointer: i64 = add-i64(base-pointer, 8)
  let store-values =
    define self(values: list(i8), index: i64): top {
      match values {
      - [] =>
        Unit
      - v :< rest =>
        let _: i64 = magic store(i8, add-i64(content-pointer, index), v)
        self(rest, add-i64(index, 1))
      }
    }
  let _ = store-values(xs, 0)
  magic cast(i64, i8-array, base-pointer)
}

define-inline i8-array-access(xs: &i8-array, i: i64): i8 {
  let ptr = magic cast(&i8-array, i64, xs)
  magic load(i8, add-i64(add-i64(ptr, 8), i))
}
