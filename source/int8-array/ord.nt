import {
  O {EQ, GT, LT},
  this.bool {False, True, bool},
  this.int {min-int},
  this.int.ord,
  this.int8-array {_get-content-pointer, int8-array, int8-array-length},
  this.memory {load-int8},
  this.ord {Ord, ord},
  this.ordering {ordering},
}

define _cmp-int8(x: int8, y: int8): ordering {
  if gt-int8(x, y) {
    GT
  } else-if lt-int8(x, y) {
    LT
  } else {
    EQ
  }
}

inline cmp-int8-array(xs1: &int8-array, xs2: &int8-array): ordering {
  let f =
    define self(ptr1: int, ptr2: int, index: int, len: int, fallback: ordering): ordering {
      if eq-int(index, len) {
        fallback
      } else {
        let v1 = load-int8(add-int(ptr1, index)) in
        let v2 = load-int8(add-int(ptr2, index)) in
        match _cmp-int8(v1, v2) {
        | EQ =>
          self(ptr1, ptr2, add-int(index, 1), len, fallback)
        | o =>
          o
        }
      }
    }
  in
  let len1 = int8-array-length(xs1) in
  let len2 = int8-array-length(xs2) in
  let min-len = min-int(len1, len2) in
  let fallback-value = this.int.ord.as-ord::compare(len1, len2) in
  let ptr1 = _get-content-pointer(xs1) in
  let ptr2 = _get-content-pointer(xs2) in
  f(ptr1, ptr2, 0, min-len, fallback-value)
}

define lt-int8-array(t1: &int8-array, t2: &int8-array): bool {
  match cmp-int8-array(t1, t2) {
  | LT =>
    True
  | _ =>
    False
  }
}

define le-int8-array(t1: &int8-array, t2: &int8-array): bool {
  match cmp-int8-array(t1, t2) {
  | GT =>
    False
  | _ =>
    True
  }
}

define gt-int8-array(t1: &int8-array, t2: &int8-array): bool {
  match cmp-int8-array(t1, t2) {
  | GT =>
    True
  | _ =>
    False
  }
}

define ge-int8-array(t1: &int8-array, t2: &int8-array): bool {
  match cmp-int8-array(t1, t2) {
  | LT =>
    False
  | _ =>
    True
  }
}

constant as-ord: ord(&int8-array) {
  Ord of {
    compare = {
      function (x, y) {
        cmp-int8-array(x, y)
      }
    },
  }
}
