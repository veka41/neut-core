import {
  Ext,
  L,
  Magic,
  Mem,
  Word,
  this.bool {False, True, bool},
  this.char {Char1, Char2, Char3, Char4, char, size},
  this.control {discard},
  this.except {Pass, none},
  this.int {max-int},
  this.int8-array {_copy-int8-array, int8-array, int8-array-access, int8-array-length, int8-array-new},
  this.list {Cons, Nil, alternate, fold-left-N, list, reverse},
  this.memory {load-int8, store-int8},
  this.pair {Pair, pair},
  this.unit {Unit, unit},
}

data text {
| Text(content: int8-array)
}

define create(xs: L.list(int8)): text {
  magic cast(int8-array, text, int8-array-new(xs))
}

define empty(): text {
  create([])
}

inline text-byte-length(t: &text): int {
  let ptr = magic cast(&text, &int8-array, t) in
  int8-array-length(ptr)
}

define _get-content-pointer(t: &text): int {
  let ptr = Magic.cast(&text, int, t) in
  let from = Mem.load-int(ptr) in
  let u = Word.size in
  add-int(add-int(ptr, mul-int(u, 2)), from)
}

define join(xs: list(text)): text {
  let len on xs =
    fold-left-N(0, xs, function (acc, x) {
      add-int(acc, text-byte-length(x))
    })
  in
  let u = Word.size in
  let u2 = mul-int(u, 2) in
  let new-text = Ext.malloc(add-int(len, u2)) in
  Mem.store-int(0, new-text);
  Mem.store-int(len, add-int(new-text, u));
  let content-ptr = add-int(new-text, u2) in
  let loop =
    define self(offset: int, xs: list(text)): unit {
      match xs {
      | Nil =>
        Unit
      | Cons(x, rest) =>
        let current-content-ptr = add-int(content-ptr, offset) in
        let x-ptr on x = _get-content-pointer(x) in
        let x-len on x = text-byte-length(x) in
        _copy-int8-array(x-ptr, current-content-ptr, 0, x-len);
        discard(x);
        self(add-int(offset, x-len), rest)
      }
    }
  in
  loop(0, xs);
  magic cast(int, text, new-text)
}

define append(t1: &text, t2: &text): text {
  let p1 = Magic.cast(&text, int, t1) in
  let p2 = Magic.cast(&text, int, t2) in
  let from1 = Mem.load-int(p1) in
  let from2 = Mem.load-int(p2) in
  let u = Word.size in
  let u2 = mul-int(u, 2) in
  let to1 = Mem.load-int(add-int(p1, u)) in
  let to2 = Mem.load-int(add-int(p2, u)) in
  let len1 = sub-int(to1, from1) in
  let len2 = sub-int(to2, from2) in
  let new-len = add-int(len1, len2) in
  let content1 = add-int(p1, u2) in
  let content2 = add-int(p2, u2) in
  let new-text = Ext.malloc(add-int(new-len, u2)) in
  Mem.store-int(0, new-text);
  Mem.store-int(new-len, add-int(new-text, u));
  let store-values =
    define store-values(target-pointer: int, content-array: int, current-index: int, array-length: int): unit {
      if eq-int(current-index, array-length) {
        Unit
      } else {
        let char = Mem.load-int8(add-int(content-array, current-index)) in
        Mem.store-int8(char, add-int(target-pointer, current-index));
        store-values(target-pointer, content-array, add-int(current-index, 1), array-length)
      }
    }
  in
  let str-pointer = add-int(new-text, u2) in
  store-values(str-pointer, add-int(content1, from1), 0, len1);
  store-values(add-int(str-pointer, len1), add-int(content2, from2), 0, len2);
  Magic.cast(int, text, new-text)
}

define get-text-length-of-int(x: int, acc: int): int {
  if lt-int(x, 0) {
    get-text-length-of-int(mul-int(x, -1), add-int(acc, 1))
  } else {
    let q = div-int(x, 10) in
    if eq-int(q, 0) {
      add-int(acc, 1)
    } else {
      get-text-length-of-int(q, add-int(acc, 1))
    }
  }
}

define access(haystack: &text, cursor: int): int8 {
  int8-array-access(magic cast(&text, &int8-array, haystack), cursor)
}

define is-empty(t: &text): bool {
  eq-int(text-byte-length(t), 0)
}

define from-int(x: int): text {
  let u = Word.size in
  let u2 = mul-int(u, 2) in
  let len = get-text-length-of-int(x, 0) in
  let ptr = Ext.malloc(add-int(len, u2)) in
  Mem.store-int(0, ptr);
  Mem.store-int(len, add-int(ptr, u));
  let content = add-int(ptr, u2) in
  let store-positive-values =
    define loop(y: int, index: int): unit {
      if lt-int(y, 10) {
        // 48 == "0"
        let digit-char = add-int8(Magic.cast(int, int8, y), 48) in
        Mem.store-int8(digit-char, add-int(content, index))
      } else {
        let q = div-int(y, 10) in
        let r = rem-int(y, 10) in
        let digit-char = add-int8(Magic.cast(int, int8, r), 48) in
        Mem.store-int8(digit-char, add-int(content, index));
        loop(q, sub-int(index, 1))
      }
    }
  in
  if lt-int(x, 0) {
    // 45 == "-"
    Mem.store-int8(45, content);
    store-positive-values(mul-int(x, -1), sub-int(len, 1))
  } else {
    store-positive-values(x, sub-int(len, 1))
  };
  Magic.cast(int, text, ptr)
}

define _get-c-string-length(ptr: int, index: int): int {
  let c = Mem.load-int8(add-int(ptr, index)) in
  if eq-int8(c, 0) {
    index
  } else {
    _get-c-string-length(ptr, add-int(index, 1))
  }
}

define _from-c-string(old-ptr: int): text {
  let u = Word.size in
  let u2 = mul-int(u, 2) in
  let len = _get-c-string-length(old-ptr, 0) in
  let new-ptr = Ext.malloc(add-int(len, u2)) in
  Mem.store-int(0, new-ptr);
  Mem.store-int(len, add-int(new-ptr, u));
  _copy-int8-array(old-ptr, add-int(new-ptr, u2), 0, len);
  Magic.cast(int, text, new-ptr)
}

define _min-int(x: int, y: int): int {
  if lt-int(x, y) {
    x
  } else {
    y
  }
}

define drop(offset: int, t: text): text {
  let _ on t =
    let ptr = Magic.cast(&text, int, t) in
    let from = Mem.load-int(ptr) in
    let to-ptr = add-int(ptr, Word.size) in
    let to = Mem.load-int(to-ptr) in
    Mem.store-int(_min-int(to, add-int(from, offset)), ptr)
  in
  t
}

define take(offset: int, t: text): text {
  let _ on t =
    let ptr = Magic.cast(&text, int, t) in
    let from = Mem.load-int(ptr) in
    let to-ptr = add-int(ptr, Word.size) in
    let to = Mem.load-int(to-ptr) in
    Mem.store-int(_min-int(to, add-int(from, offset)), to-ptr)
  in
  t
}

define drop-N(offset: int, t: &text): text {
  let content-ptr = _get-content-pointer(t) in
  let orig-size = text-byte-length(t) in
  let new-size = max-int(0, sub-int(orig-size, offset)) in
  let new-ptr = Ext.malloc(add-int(new-size, mul-int(Word.size, 2))) in
  Mem.store-int(0, new-ptr);
  Mem.store-int(new-size, add-int(new-ptr, Word.size));
  let new-content-ptr = add-int(new-ptr, mul-int(Word.size, 2)) in
  let adjusted-offset = _min-int(offset, orig-size) in
  let content-ptr' = add-int(content-ptr, adjusted-offset) in
  _copy-int8-array(content-ptr', new-content-ptr, 0, new-size);
  Magic.cast(int, text, new-ptr)
}

define take-N(offset: int, t: &text): text {
  // get info from old text
  let ptr = core.magic.cast(&text, int, t) in
  let to = Mem.load-int(add-int(ptr, core.word.size)) in
  let new-size = _min-int(to, offset) in
  let new-ptr = Ext.malloc(add-int(offset, mul-int(core.word.size, 2))) in
  Mem.store-int(0, new-ptr);
  Mem.store-int(new-size, add-int(new-ptr, core.word.size));
  let content-ptr = _get-content-pointer(t) in
  let new-content-ptr = add-int(new-ptr, mul-int(core.word.size, 2)) in
  _copy-int8-array(content-ptr, new-content-ptr, 0, new-size);
  core.magic.cast(int, text, new-ptr)
}

define slice-N(start: int, size: int, t: &text): text {
  let start = max-int(start, 0) in
  let size = max-int(size, 0) in
  let ptr = Magic.cast(&text, int, t) in
  let content-ptr = _get-content-pointer(t) in
  let to-ptr = add-int(ptr, Word.size) in
  let to = Mem.load-int(to-ptr) in
  let new-size = _min-int(size, to) in
  let new-ptr = Ext.malloc(add-int(new-size, mul-int(Word.size, 2))) in
  Mem.store-int(0, new-ptr);
  Mem.store-int(new-size, add-int(new-ptr, Word.size));
  let new-content-ptr = add-int(new-ptr, mul-int(Word.size, 2)) in
  _copy-int8-array(add-int(content-ptr, start), new-content-ptr, 0, new-size);
  Magic.cast(int, text, new-ptr)
}

define _match-text-content(ptr1: int, ptr2: int, len: int): bool {
  let f =
    define helper(cursor: int): bool {
      if eq-int(cursor, len) {
        True
      } else {
        let c1: int8 = Mem.load-int8(add-int(ptr1, cursor)) in
        let c2: int8 = Mem.load-int8(add-int(ptr2, cursor)) in
        if eq-int8(c1, c2) {
          helper(add-int(cursor, 1))
        } else {
          False
        }
      }
    }
  in
  f(0)
}

define break-on(needle: &text, haystack: &text): pair(text, text) {
  let ptr = _get-content-pointer(haystack) in
  let ptr2 = _get-content-pointer(needle) in
  let len = text-byte-length(haystack) in
  let needle-len = text-byte-length(needle) in
  let f =
    define loop(cursor: int): pair(text, text) {
      let rem-len = sub-int(len, cursor) in
      if lt-int(rem-len, needle-len) {
        Pair(*haystack, empty())
      } else {
        let ptr1 = add-int(ptr, cursor) in
        if _match-text-content(ptr1, ptr2, needle-len) {
          let former = take-N(cursor, haystack) in
          let latter = drop-N(cursor, haystack) in
          Pair(former, latter)
        } else {
          loop(add-int(cursor, 1))
        }
      }
    }
  in
  f(0)
}

define _appendR(t1: text, t2: text): text {
  let t on t1, t2 = append(t1, t2) in
  let _ = t1 in
  let _ = t2 in
  t
}

define intercalate(sep: text, xs: list(text)): text {
  join(this.list.intercalate(sep, xs))
}

data _char {
| _Char1
| _Char2
| _Char3
| _Char4
| _Invalid
}

define _char-as-int(c: _char): int {
  match c {
  | _Char1 =>
    1
  | _Char2 =>
    2
  | _Char3 =>
    3
  | _Char4 =>
    4
  | _Invalid =>
    // for now
    0
  }
}

define _get-head-char(t: &text, index: int): int8 {
  let ptr = _get-content-pointer(t) in
  load-int8(add-int(ptr, index))
}

define char-to-bitseq-2(raw-char: int16): char {
  let piece-0 = trunc-int16-int8(lshr-int16(and-int16(0b_1111_1111_0000_0000, raw-char), 8)) in
  let piece-1 = trunc-int16-int8(and-int16(0b_0000_0000_1111_1111, raw-char)) in
  Char2(piece-0, piece-1)
}

define char-to-bitseq-3(raw-char: int24): char {
  let piece-0 = trunc-int24-int8(lshr-int24(and-int24(0b_1111_1111_0000_0000_0000_0000, raw-char), 16)) in
  let piece-1 = trunc-int24-int8(lshr-int24(and-int24(0b_0000_0000_1111_1111_0000_0000, raw-char), 8)) in
  let piece-2 = trunc-int24-int8(and-int24(0b_0000_0000_0000_0000_1111_1111, raw-char)) in
  Char3(piece-0, piece-1, piece-2)
}

define char-to-bitseq-4(raw-char: int32): char {
  let piece-0 = trunc-int32-int8(lshr-int32(and-int32(0b_1111_1111_0000_0000_0000_0000_0000_0000, raw-char), 24)) in
  let piece-1 = trunc-int32-int8(lshr-int32(and-int32(0b_0000_0000_1111_1111_0000_0000_0000_0000, raw-char), 16)) in
  let piece-2 = trunc-int32-int8(lshr-int32(and-int32(0b_0000_0000_0000_0000_1111_1111_0000_0000, raw-char), 8)) in
  let piece-3 = trunc-int32-int8(and-int32(0b_0000_0000_0000_0000_0000_0000_1111_1111, raw-char)) in
  Char4(piece-0, piece-1, piece-2, piece-3)
}

define _get-head-char-2(t: &text, index: int): char {
  let ch-0 = _get-head-char(t, index) in
  let ch-1 = _get-head-char(t, add-int(index, 1)) in
  Char2(ch-0, ch-1)
}

define _get-head-char-3(t: &text, index: int): char {
  let ch-0 = _get-head-char(t, index) in
  let ch-1 = _get-head-char(t, add-int(index, 1)) in
  let ch-2 = _get-head-char(t, add-int(index, 2)) in
  Char3(ch-0, ch-1, ch-2)
}

define _get-head-char-4(t: &text, index: int): char {
  let ch-0 = _get-head-char(t, index) in
  let ch-1 = _get-head-char(t, add-int(index, 1)) in
  let ch-2 = _get-head-char(t, add-int(index, 2)) in
  let ch-3 = _get-head-char(t, add-int(index, 3)) in
  Char4(ch-0, ch-1, ch-2, ch-3)
}

define _categorize-char(char: int8): _char {
  if eq-int8(and-int8(char, 0x80), 0x00) {
    // 0x00 = 0000 0000
    // 0x80 = 1000 0000
    _Char1
  } else-if eq-int8(and-int8(char, 0xE0), 0xC0) {
    // 0xC0 = 1100 0000
    // 0xE0 = 1110 0000
    _Char2
  } else-if eq-int8(and-int8(char, 0xF0), 0xE0) {
    // 0xE0 = 1110 0000
    // 0xF0 = 1111 0000
    _Char3
  } else-if eq-int8(and-int8(char, 0xF8), 0xF0) {
    // 0xF0 = 1111 0000
    // 0xF8 = 1111 1000
    _Char4
  } else {
    _Invalid
  }
}

define _length(t: &text, len: int, index: int, acc: int): int {
  if ge-int(index, len) {
    acc
  } else {
    let head-char = _get-head-char(t, index) in
    let category = _categorize-char(head-char) in
    let char-len = _char-as-int(category) in
    _length(t, len, add-int(index, char-len), add-int(acc, 1))
  }
}

define length(t: &text): int {
  let len = text-byte-length(t) in
  _length(t, len, 0, 0)
}

define split-on(needle: &text, haystack: &text): list(text) {
  let haystack-ptr = _get-content-pointer(haystack) in
  let needle-ptr = _get-content-pointer(needle) in
  let len = text-byte-length(haystack) in
  let needle-len = text-byte-length(needle) in
  let f =
    define loop(pivot: int, cursor: int): list(text) {
      let rem-len = sub-int(len, add-int(pivot, cursor)) in
      if lt-int(rem-len, needle-len) {
        [drop-N(pivot, haystack)]
      } else {
        let current-ptr = add-int(haystack-ptr, add-int(pivot, cursor)) in
        if _match-text-content(current-ptr, needle-ptr, needle-len) {
          let piece = slice-N(pivot, cursor, haystack) in
          let next-pivot = add-int(pivot, add-int(cursor, needle-len)) in
          let rest = loop(next-pivot, 0) in
          Cons(piece, rest)
        } else {
          loop(pivot, add-int(cursor, 1))
        }
      }
    }
  in
  if eq-int(needle-len, 0) {
    []
  } else {
    f(0, 0)
  }
}

define replace(from: &text, to: text, haystack: &text): text {
  this.text.intercalate(to, split-on(from, haystack))
}

define _format(fmt: &text, args: list(text)): list(text) {
  alternate(split-on("{}", fmt), args)
}

define format(fmt: &text, args: list(text)): text {
  join(_format(fmt, args))
}

define _unpack(t: &text, len: int, index: int, acc: list(char)): list(char) {
  if ge-int(index, len) {
    reverse(acc)
  } else {
    let head-char = _get-head-char(t, index) in
    let category = _categorize-char(head-char) in
    let char-len = _char-as-int(category) in
    match category {
    | _Char1 =>
      let ch = Char1(head-char) in
      _unpack(t, len, add-int(index, char-len), Cons(ch, acc))
    | _Char2 =>
      let ch = _get-head-char-2(t, index) in
      _unpack(t, len, add-int(index, char-len), Cons(ch, acc))
    | _Char3 =>
      let ch = _get-head-char-3(t, index) in
      _unpack(t, len, add-int(index, char-len), Cons(ch, acc))
    | _Char4 =>
      let ch = _get-head-char-4(t, index) in
      _unpack(t, len, add-int(index, char-len), Cons(ch, acc))
    | _Invalid =>
      _unpack(t, len, add-int(index, char-len), acc)
    }
  }
}

define unpack(t: &text): list(char) {
  let len = text-byte-length(t) in
  _unpack(t, len, 0, [])
}

define _char-list-length(xs: &list(char), acc: int): int {
  case xs {
  | Nil =>
    acc
  | Cons(x, rest) =>
    _char-list-length(rest, add-int(acc, size(x)))
  }
}

define pack(xs: &list(char)): text {
  let len = _char-list-length(xs, 0) in
  let u = Word.size in
  let u2 = mul-int(u, 2) in
  let new-text = Ext.malloc(add-int(len, u2)) in
  Mem.store-int(0, new-text);
  Mem.store-int(len, add-int(new-text, u));
  let content-ptr = add-int(new-text, u2) in
  let loop =
    define self(offset: int, xs: &list(char)): unit {
      case xs {
      | Nil =>
        Unit
      | Cons(x, rest) =>
        let current-content-ptr = add-int(content-ptr, offset) in
        case x {
        | Char1(c0) =>
          store-int8(*c0, current-content-ptr);
          self(add-int(offset, 1), rest)
        | Char2(c0, c1) =>
          store-int8(*c0, current-content-ptr);
          store-int8(*c1, add-int(current-content-ptr, 1));
          self(add-int(offset, 2), rest)
        | Char3(c0, c1, c2) =>
          store-int8(*c0, current-content-ptr);
          store-int8(*c1, add-int(current-content-ptr, 1));
          store-int8(*c2, add-int(current-content-ptr, 2));
          self(add-int(offset, 3), rest)
        | Char4(c0, c1, c2, c3) =>
          store-int8(*c0, current-content-ptr);
          store-int8(*c1, add-int(current-content-ptr, 1));
          store-int8(*c2, add-int(current-content-ptr, 2));
          store-int8(*c3, add-int(current-content-ptr, 3));
          self(add-int(offset, 4), rest)
        }
      }
    }
  in
  loop(0, xs);
  magic cast(int, text, new-text)
}

define reverse(t: &text): text {
  // for now
  let xs = this.list.reverse(unpack(t)) in
  let result on xs = pack(xs) in
  let _ = xs in
  result
}

// O(1)
define uncons(t: text): ?pair(char, text) {
  let len on t = text-byte-length(t) in
  if eq-int(len, 0) {
    none()
  } else {
    let head-char on t = _get-head-char(t, 0) in
    let category = _categorize-char(head-char) in
    let ch on t =
      match category {
      | _Char1 =>
        Char1(head-char)
      | _Char2 =>
        _get-head-char-2(t, 0)
      | _Char3 =>
        _get-head-char-3(t, 0)
      | _Char4 =>
        _get-head-char-4(t, 0)
      | _Invalid =>
        // unicode invalid char
        Char3(0xEF, 0xBF, 0xBE)
      }
    in
    let char-len = _char-as-int(category) in
    let t = drop(char-len, t) in
    Pass(Pair(ch, t))
  }
}
