import {
- this.i8-array
- this.bool
- this.option
- this.list => L
- this.product
- this.top
- this.external => ext
- this.memory => mem
- this.magic => magic
}

export {
- text
- append
- create
- empty
- from-i64
- unsafe-get-content-pointer
- intercalate
- length
- tail
- uncons
}

alias-opaque text {
  i8-array
}

define create(xs: L.list(i8)): text {
  magic cast(i8-array, text, i8-array-new(xs))
}

define empty(): text {
  create([])
}

define append(t1: &text, t2: &text): text {
  let p1 = magic.cast(&text, i64, t1)
  let p2 = magic.cast(&text, i64, t2)
  let from1 = mem.load-i64(p1)
  let from2 = mem.load-i64(p2)
  let to1 = mem.load-i64(add-i64(p1, 8))
  let to2 = mem.load-i64(add-i64(p2, 8))
  let len1 = sub-i64(to1, from1)
  let len2 = sub-i64(to2, from2)
  let new-len = add-i64(len1, len2)
  let content1 = add-i64(p1, 16)
  let content2 = add-i64(p2, 16)
  let new-text = ext.malloc(add-i64(new-len, 16))
  mem.store-i64(new-text, 0: i64)
  mem.store-i64(add-i64(new-text, 8), new-len)
  let store-values =
    define self(target-pointer: i64, content-array: i64, current-index: i64, array-length: i64): top {
      if eq-i64(current-index, array-length) {
        Unit
      } else {
        let char = mem.load-i8(add-i64(content-array, current-index))
        mem.store-i8(add-i64(target-pointer, current-index), char)
        self(target-pointer, content-array, add-i64(current-index, 1), array-length)
      }
    }
  let str-pointer = add-i64(new-text, 16)
  store-values(str-pointer, add-i64(content1, from2), 0, len1)
  store-values(add-i64(str-pointer, len1), add-i64(content2, from2), 0, len2)
  magic.cast(i64, text, new-text)
}

define unsafe-get-content-pointer(t: &text): i64 {
  let ptr = magic.cast(&text, i64, t)
  let from = mem.load-i64(ptr)
  add-i64(add-i64(ptr, 16), from)
}

define get-text-length-of-i64(x: i64, acc: i64): i64 {
  if lt-i64(x, 0) {
    get-text-length-of-i64(mul-i64(x, -1), add-i64(acc, 1))
  } else {
    let q = div-i64(x, 10)
    if eq-i64(q, 0) {
      add-i64(acc, 1)
    } else {
      get-text-length-of-i64(q, add-i64(acc, 1))
    }
  }
}

define from-i64(x: i64): text {
  let len = get-text-length-of-i64(x, 0)
  let ptr = ext.malloc(add-i64(len, 16))
  mem.store-i64(ptr, 0: i64)
  mem.store-i64(add-i64(ptr, 8), len)
  let content = add-i64(ptr, 16)
  let store-positive-values =
    define loop(y: i64, index: i64): top {
      if lt-i64(y, 10) {
        let digit-char = add-i8(magic.cast(i64, i8, y), 48) // 48 == "0"
        mem.store-i8(add-i64(content, index), digit-char)
      } else {
        let q = div-i64(y, 10)
        let r = rem-i64(y, 10)
        let digit-char = add-i8(magic.cast(i64, i8, r), 48)
        mem.store-i8(add-i64(content, index), digit-char)
        loop(q, sub-i64(index, 1))
      }
    }
  if lt-i64(x, 0) {
    mem.store-i8(content, 45) // 45 == "-"
    store-positive-values(mul-i64(x, -1), sub-i64(len, 1))
  } else {
    store-positive-values(x, sub-i64(len, 1))
  }
  magic.cast(i64, text, ptr)
}

define uncons(t: text): ?product(i64, text) {
  let ptr = magic.cast(text, i64, t)
  let from = mem.load-i64(ptr)
  let to = mem.load-i64(add-i64(ptr, 8))
  if lt-i64(add-i64(from, 1), to) {
    let head-char = mem.load-i64(add-i64(add-i64(ptr, 16), from))
    mem.store-i64(ptr, add-i64(from, 1))
    Some(tuple(head-char, magic.cast(i64, text, ptr)))
  } else {
    let _: text = magic.cast(i64, text, ptr)
    None
  }
}

define tail(t: text): ?text {
  let ptr = magic.cast(text, i64, t) // must be irreducible
  let from = mem.load-i64(ptr)
  let to = mem.load-i64(add-i64(ptr, 8))
  if lt-i64(add-i64(from, 1), to) {
    mem.store-i64(ptr, add-i64(from, 1))
    Some(magic.cast(i64, text, ptr))
  } else {
    let _: text = magic.cast(i64, text, ptr)
    None
  }
}

define length(t: &text): i64 {
  let ptr = magic.cast(&text, i64, t)
  let from = mem.load-i64(ptr)
  let to = mem.load-i64(add-i64(ptr, 8))
  sub-i64(to, from)
}

// a slow implementation; optimizable using direct malloc
define intercalate(sep: &text, xs: &L.list(&text)): text {
  case xs {
  - [] =>
    empty()
  - [t] =>
    !!t
  - t :< ts =>
    let str-head = this.text.append(!t, sep)
    let str-cont = intercalate(sep, ts)
    let result on str-head, str-cont = this.text.append(str-head, str-cont)
    let _ = str-head
    let _ = str-cont
    result
  }
}
