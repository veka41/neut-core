import {
  Ext,
  L,
  Magic,
  Mem,
  Word,
  this.binary {_copy-binary, binary, binary-access, binary-length, binary-new},
  this.bool {False, True, bool},
  this.control {discard},
  this.either {Right, none},
  this.int {max-int, min-int},
  this.list {Cons, Nil, fold-left-N, list, reverse},
  this.memory {load-int8},
  this.pair {Pair, pair},
  this.rune {_Rune, load-rune, rune, size-by-head-byte, store-rune},
  this.unit {Unit, unit},
}

data text {
| Text(content: binary)
}

define create(xs: L.list(int8)): text {
  magic cast(binary, text, binary-new(xs))
}

define empty(): text {
  create([])
}

inline text-byte-length(t: &text): int {
  let ptr = magic cast(&text, &binary, t) in
  binary-length(ptr)
}

define _get-content-pointer(t: &text): int {
  let ptr = Magic.cast(&text, int, t) in
  let from = Mem.load-int(ptr) in
  let u = Word.size in
  add-int(add-int(ptr, mul-int(u, 2)), from)
}

define join(xs: list(text)): text {
  let len on xs =
    fold-left-N(0, xs, function (acc, x) {
      add-int(acc, text-byte-length(x))
    })
  in
  let u = Word.size in
  let u2 = mul-int(u, 2) in
  let new-text = Ext.malloc(add-int(len, u2)) in
  Mem.store-int(0, new-text);
  Mem.store-int(len, add-int(new-text, u));
  let content-ptr = add-int(new-text, u2) in
  let loop =
    define self(offset: int, xs: list(text)): unit {
      match xs {
      | Nil =>
        Unit
      | Cons(x, rest) =>
        let current-content-ptr = add-int(content-ptr, offset) in
        let x-ptr on x = _get-content-pointer(x) in
        let x-len on x = text-byte-length(x) in
        _copy-binary(x-ptr, current-content-ptr, 0, x-len);
        discard(x);
        self(add-int(offset, x-len), rest)
      }
    }
  in
  loop(0, xs);
  magic cast(int, text, new-text)
}

define join-N(xs: list(&text)): text {
  let len on xs =
    fold-left-N(0, xs, function (acc, x) {
      add-int(acc, text-byte-length(*x))
    })
  in
  let u = Word.size in
  let u2 = mul-int(u, 2) in
  let new-text = Ext.malloc(add-int(len, u2)) in
  Mem.store-int(0, new-text);
  Mem.store-int(len, add-int(new-text, u));
  let content-ptr = add-int(new-text, u2) in
  let loop =
    define self(offset: int, xs: list(&text)): unit {
      match xs {
      | Nil =>
        Unit
      | Cons(x, rest) =>
        let current-content-ptr = add-int(content-ptr, offset) in
        let x-ptr = _get-content-pointer(x) in
        let x-len = text-byte-length(x) in
        _copy-binary(x-ptr, current-content-ptr, 0, x-len);
        discard(x);
        self(add-int(offset, x-len), rest)
      }
    }
  in
  loop(0, xs);
  magic cast(int, text, new-text)
}

define append(t1: &text, t2: &text): text {
  let p1 = Magic.cast(&text, int, t1) in
  let p2 = Magic.cast(&text, int, t2) in
  let from1 = Mem.load-int(p1) in
  let from2 = Mem.load-int(p2) in
  let u = Word.size in
  let u2 = mul-int(u, 2) in
  let to1 = Mem.load-int(add-int(p1, u)) in
  let to2 = Mem.load-int(add-int(p2, u)) in
  let len1 = sub-int(to1, from1) in
  let len2 = sub-int(to2, from2) in
  let new-len = add-int(len1, len2) in
  let content1 = add-int(p1, u2) in
  let content2 = add-int(p2, u2) in
  let new-text = Ext.malloc(add-int(new-len, u2)) in
  Mem.store-int(0, new-text);
  Mem.store-int(new-len, add-int(new-text, u));
  let !store-values =
    define store-values(target-pointer: int, content-array: int, current-index: int, array-length: int): unit {
      if eq-int(current-index, array-length) {
        Unit
      } else {
        let char = Mem.load-int8(add-int(content-array, current-index)) in
        Mem.store-int8(char, add-int(target-pointer, current-index));
        store-values(target-pointer, content-array, add-int(current-index, 1), array-length)
      }
    }
  in
  let str-pointer = add-int(new-text, u2) in
  !store-values(str-pointer, add-int(content1, from1), 0, len1);
  !store-values(add-int(str-pointer, len1), add-int(content2, from2), 0, len2);
  Magic.cast(int, text, new-text)
}

define _access(haystack: &text, cursor: int): int8 {
  binary-access(magic cast(&text, &binary, haystack), cursor)
}

define is-empty(t: &text): bool {
  eq-int(text-byte-length(t), 0)
}

define _get-c-string-length(ptr: int, index: int): int {
  let c = Mem.load-int8(add-int(ptr, index)) in
  if eq-int8(c, 0) {
    index
  } else {
    _get-c-string-length(ptr, add-int(index, 1))
  }
}

define _from-c-string(old-ptr: int): text {
  let u = Word.size in
  let u2 = mul-int(u, 2) in
  let len = _get-c-string-length(old-ptr, 0) in
  let new-ptr = Ext.malloc(add-int(len, u2)) in
  Mem.store-int(0, new-ptr);
  Mem.store-int(len, add-int(new-ptr, u));
  _copy-binary(old-ptr, add-int(new-ptr, u2), 0, len);
  Magic.cast(int, text, new-ptr)
}

// O(1)
define _drop(offset: int, t: text): text {
  let offset = max-int(0, offset) in
  let _ on t =
    let ptr = Magic.cast(&text, int, t) in
    let from = Mem.load-int(ptr) in
    let to-ptr = add-int(ptr, Word.size) in
    let to = Mem.load-int(to-ptr) in
    Mem.store-int(min-int(to, add-int(from, offset)), ptr)
  in
  t
}

// O(1)
define _take(offset: int, t: text): text {
  let offset = max-int(0, offset) in
  let _ on t =
    let ptr = Magic.cast(&text, int, t) in
    let from = Mem.load-int(ptr) in
    let to-ptr = add-int(ptr, Word.size) in
    let to = Mem.load-int(to-ptr) in
    Mem.store-int(min-int(to, add-int(from, offset)), to-ptr)
  in
  t
}

// O(1)
define _slice(start: int, size: int, t: text): text {
  _take(size, _drop(start, t))
}

define _drop-N(offset: int, t: &text): text {
  let content-ptr = _get-content-pointer(t) in
  let orig-size = text-byte-length(t) in
  let new-size = max-int(0, sub-int(orig-size, offset)) in
  let new-ptr = Ext.malloc(add-int(new-size, mul-int(Word.size, 2))) in
  Mem.store-int(0, new-ptr);
  Mem.store-int(new-size, add-int(new-ptr, Word.size));
  let new-content-ptr = add-int(new-ptr, mul-int(Word.size, 2)) in
  let adjusted-offset = min-int(offset, orig-size) in
  let content-ptr' = add-int(content-ptr, adjusted-offset) in
  _copy-binary(content-ptr', new-content-ptr, 0, new-size);
  Magic.cast(int, text, new-ptr)
}

define _take-N(offset: int, t: &text): text {
  // get info from old text
  let ptr = core.magic.cast(&text, int, t) in
  let to = Mem.load-int(add-int(ptr, core.word.size)) in
  let new-size = min-int(to, offset) in
  let new-ptr = Ext.malloc(add-int(offset, mul-int(core.word.size, 2))) in
  Mem.store-int(0, new-ptr);
  Mem.store-int(new-size, add-int(new-ptr, core.word.size));
  let content-ptr = _get-content-pointer(t) in
  let new-content-ptr = add-int(new-ptr, mul-int(core.word.size, 2)) in
  _copy-binary(content-ptr, new-content-ptr, 0, new-size);
  core.magic.cast(int, text, new-ptr)
}

define _slice-N(start: int, size: int, t: &text): text {
  let start = max-int(start, 0) in
  let size = max-int(size, 0) in
  let ptr = Magic.cast(&text, int, t) in
  let content-ptr = _get-content-pointer(t) in
  let to-ptr = add-int(ptr, Word.size) in
  let to = Mem.load-int(to-ptr) in
  let new-size = min-int(size, to) in
  let new-ptr = Ext.malloc(add-int(new-size, mul-int(Word.size, 2))) in
  Mem.store-int(0, new-ptr);
  Mem.store-int(new-size, add-int(new-ptr, Word.size));
  let new-content-ptr = add-int(new-ptr, mul-int(Word.size, 2)) in
  _copy-binary(add-int(content-ptr, start), new-content-ptr, 0, new-size);
  Magic.cast(int, text, new-ptr)
}

define _match-text-content(ptr1: int, ptr2: int, len: int): bool {
  let f =
    define helper(cursor: int): bool {
      if eq-int(cursor, len) {
        True
      } else {
        let c1: int8 = Mem.load-int8(add-int(ptr1, cursor)) in
        let c2: int8 = Mem.load-int8(add-int(ptr2, cursor)) in
        if eq-int8(c1, c2) {
          helper(add-int(cursor, 1))
        } else {
          False
        }
      }
    }
  in
  f(0)
}

define break-on(needle: &text, haystack: &text): pair(text, text) {
  let ptr = _get-content-pointer(haystack) in
  let ptr2 = _get-content-pointer(needle) in
  let len = text-byte-length(haystack) in
  let needle-len = text-byte-length(needle) in
  let f =
    define loop(cursor: int): pair(text, text) {
      let rem-len = sub-int(len, cursor) in
      if lt-int(rem-len, needle-len) {
        Pair(*haystack, empty())
      } else {
        let ptr1 = add-int(ptr, cursor) in
        if _match-text-content(ptr1, ptr2, needle-len) {
          let former = _take-N(cursor, haystack) in
          let latter = _drop-N(cursor, haystack) in
          Pair(former, latter)
        } else {
          loop(add-int(cursor, 1))
        }
      }
    }
  in
  f(0)
}

define intercalate(sep: text, xs: list(text)): text {
  join(this.list.intercalate(sep, xs))
}

define intercalate-N(sep: &text, xs: list(&text)): text {
  join-N(this.list.intercalate(sep, xs))
}

define _get-head-byte(t: &text, index: int): int8 {
  let ptr = _get-content-pointer(t) in
  load-int8(add-int(ptr, index))
}

define _get-rune-size-at(t: &text, index: int): int {
  let head-byte = _get-head-byte(t, index) in
  size-by-head-byte(head-byte)
}

define singleton(value: rune): text {
  let s = this.rune.size(value) in
  let _Rune(value) = value in
  match s {
  | 1 =>
    let piece-0 = trunc-int32-int8(value) in
    create([piece-0])
  | 2 =>
    let value = trunc-int32-int16(value) in
    let piece-0 = trunc-int16-int8(lshr-int16(and-int16(0b_1111_1111_0000_0000, value), 8)) in
    let piece-1 = trunc-int16-int8(lshr-int16(and-int16(0b_0000_0000_1111_1111, value), 0)) in
    create([piece-0, piece-1])
  | 3 =>
    let value = trunc-int32-int24(value) in
    let piece-0 = trunc-int24-int8(lshr-int24(and-int24(0b_1111_1111_0000_0000_0000_0000, value), 16)) in
    let piece-1 = trunc-int24-int8(lshr-int24(and-int24(0b_0000_0000_1111_1111_0000_0000, value), 8)) in
    let piece-2 = trunc-int24-int8(lshr-int24(and-int24(0b_0000_0000_0000_0000_1111_1111, value), 0)) in
    create([piece-0, piece-1, piece-2])
  | 4 =>
    let piece-0 = trunc-int32-int8(lshr-int32(and-int32(0b_1111_1111_0000_0000_0000_0000_0000_0000, value), 24)) in
    let piece-1 = trunc-int32-int8(lshr-int32(and-int32(0b_0000_0000_1111_1111_0000_0000_0000_0000, value), 16)) in
    let piece-2 = trunc-int32-int8(lshr-int32(and-int32(0b_0000_0000_0000_0000_1111_1111_0000_0000, value), 8)) in
    let piece-3 = trunc-int32-int8(lshr-int32(and-int32(0b_0000_0000_0000_0000_0000_0000_1111_1111, value), 0)) in
    create([piece-0, piece-1, piece-2, piece-3])
  | _ =>
    // U+FFFE Noncharacter
    create([0xef, 0xbf, 0xbe])
  }
}

define _length(t: &text, len: int, index: int, acc: int): int {
  if ge-int(index, len) {
    acc
  } else {
    let rune-size = _get-rune-size-at(t, index) in
    _length(t, len, add-int(index, rune-size), add-int(acc, 1))
  }
}

define length(t: &text): int {
  let len = text-byte-length(t) in
  _length(t, len, 0, 0)
}

define split-on(needle: &text, haystack: &text): list(text) {
  let haystack-ptr = _get-content-pointer(haystack) in
  let needle-ptr = _get-content-pointer(needle) in
  let len = text-byte-length(haystack) in
  let needle-len = text-byte-length(needle) in
  let f =
    define loop(pivot: int, cursor: int): list(text) {
      let rem-len = sub-int(len, add-int(pivot, cursor)) in
      if lt-int(rem-len, needle-len) {
        [_drop-N(pivot, haystack)]
      } else {
        let current-ptr = add-int(haystack-ptr, add-int(pivot, cursor)) in
        if _match-text-content(current-ptr, needle-ptr, needle-len) {
          let piece = _slice-N(pivot, cursor, haystack) in
          let next-pivot = add-int(pivot, add-int(cursor, needle-len)) in
          let rest = loop(next-pivot, 0) in
          Cons(piece, rest)
        } else {
          loop(pivot, add-int(cursor, 1))
        }
      }
    }
  in
  if eq-int(needle-len, 0) {
    []
  } else {
    f(0, 0)
  }
}

define replace(from: &text, to: text, haystack: &text): text {
  this.text.intercalate(to, split-on(from, haystack))
}

// [x1], [y1, y2] => [x1]
// [x1, x2], [y1, y2, y3] => [x1, y1, x2]
// [x1, x2, x3], [y1, y2] => [x1, y1, x2, y2, x3]
define _alternate<a>(xs: list(a), ys: list(a)): list(a) {
  match xs, ys {
  | Nil, _ =>
    Nil
  | Cons(x', Nil), _ =>
    Cons(x', Nil)
  | Cons(x1, Cons(x2, xs')), Nil =>
    Cons(x1, Cons(x2, xs'))
  | Cons(x1, Cons(x2, xs')), Cons(y', ys') =>
    Cons(x1, Cons(y', _alternate(Cons(x2, xs'), ys')))
  }
}

define _format(fmt: &text, args: list(text)): list(text) {
  _alternate(split-on("{}", fmt), args)
}

define format(fmt: &text, args: list(text)): text {
  join(_format(fmt, args))
}

define _unpack(ptr: int, len: int, index: int, acc: list(rune)): list(rune) {
  if ge-int(index, len) {
    reverse(acc)
  } else {
    let r = load-rune(add-int(ptr, index)) in
    let s = this.rune.size(r) in
    _unpack(ptr, len, add-int(index, s), Cons(r, acc))
  }
}

define unpack(t: &text): list(rune) {
  let ptr = _get-content-pointer(t) in
  let len = text-byte-length(t) in
  _unpack(ptr, len, 0, [])
}

define _char-list-length(xs: &list(rune), acc: int): int {
  case xs {
  | Nil =>
    acc
  | Cons(x, rest) =>
    _char-list-length(rest, add-int(acc, this.rune.size(*x)))
  }
}

define pack(xs: &list(rune)): text {
  let len = _char-list-length(xs, 0) in
  let u = Word.size in
  let u2 = mul-int(u, 2) in
  let new-text = Ext.malloc(add-int(len, u2)) in
  Mem.store-int(0, new-text);
  Mem.store-int(len, add-int(new-text, u));
  let content-ptr = add-int(new-text, u2) in
  let loop =
    define self(offset: int, xs: &list(rune)): unit {
      case xs {
      | Nil =>
        Unit
      | Cons(x, rest) =>
        let current-content-ptr = add-int(content-ptr, offset) in
        let stored-bytes = store-rune(*x, current-content-ptr) in
        self(add-int(offset, stored-bytes), rest)
      }
    }
  in
  loop(0, xs);
  magic cast(int, text, new-text)
}

define reverse(t: &text): text {
  // for now
  pin xs = this.list.reverse(unpack(t)) in
  pack(xs)
}

define _get-rune(t: &text, index: int): rune {
  let ptr = add-int(_get-content-pointer(t), index) in
  load-rune(ptr)
}

// // O(1)
define uncons(t: text): ?pair(rune, text) {
  let len on t = text-byte-length(t) in
  if eq-int(len, 0) {
    none()
  } else {
    let ch on t = _get-rune(t, 0) in
    let char-len = this.rune.size(ch) in
    let t = _drop(char-len, t) in
    Right(Pair(ch, t))
  }
}

define _find-pivot(char-len: int, len: int, t: &text, index: int, char-count: int): int {
  if ge-int(index, len) {
    index
  } else-if ge-int(char-count, char-len) {
    index
  } else {
    let char-size = _get-rune-size-at(t, index) in
    _find-pivot(char-len, len, t, add-int(index, char-size), add-int(char-count, 1))
  }
}

define take(n: int, t: text): text {
  let len on t = text-byte-length(t) in
  let pivot on t = _find-pivot(n, len, t, 0, 0) in
  _slice(0, pivot, t)
}

define take-N(n: int, t: &text): text {
  let len = text-byte-length(t) in
  let pivot = _find-pivot(n, len, t, 0, 0) in
  _slice-N(0, pivot, t)
}

define drop(n: int, t: text): text {
  let len on t = text-byte-length(t) in
  let pivot on t = _find-pivot(n, len, t, 0, 0) in
  _slice(pivot, len, t)
}

define drop-N(n: int, t: &text): text {
  let len = text-byte-length(t) in
  let pivot = _find-pivot(n, len, t, 0, 0) in
  _slice-N(pivot, len, t)
}

define slice(start: int, size: int, t: text): text {
  let len on t = text-byte-length(t) in
  let start-byte-index on t = _find-pivot(start, len, t, 0, 0) in
  let end-byte-index on t = _find-pivot(size, len, t, start-byte-index, 0) in
  _slice(start-byte-index, sub-int(end-byte-index, start-byte-index), t)
}

define slice-N(start: int, size: int, t: &text): text {
  let len = text-byte-length(t) in
  let start-byte-index = _find-pivot(start, len, t, 0, 0) in
  let end-byte-index = _find-pivot(size, len, t, start-byte-index, 0) in
  _slice-N(start-byte-index, sub-int(end-byte-index, start-byte-index), t)
}

inline take-while(pred: (rune) -> bool, t: text): text {
  let f =
    define self(t: text, index: int): text {
      let len on t = text-byte-length(t) in
      if ge-int(index, len) {
        take(index, t)
      } else {
        let ch on t = _get-rune(t, index) in
        if pred(ch) {
          let char-len = this.rune.size(ch) in
          self(t, add-int(index, char-len))
        } else {
          take(index, t)
        }
      }
    }
  in
  f(t, 0)
}

inline take-while-N(pred: (rune) -> bool, t: &text): text {
  let len = text-byte-length(t) in
  let f =
    define self(index: int, acc: list(rune)): list(rune) {
      if ge-int(index, len) {
        core.list.reverse(acc)
      } else {
        let ch = _get-rune(t, index) in
        if pred(ch) {
          let char-len = this.rune.size(ch) in
          self(add-int(index, char-len), Cons(ch, acc))
        } else {
          core.list.reverse(acc)
        }
      }
    }
  in
  pin cs = f(0, []) in
  pack(cs)
}

inline drop-while(pred: (rune) -> bool, t: text): text {
  let f =
    define self(t: text): text {
      let b on t = this.text.is-empty(t) in
      if b {
        empty()
      } else {
        let ch on t = _get-rune(t, 0) in
        let cond = pred(ch) in
        if cond {
          self(drop(1, t))
        } else {
          t
        }
      }
    }
  in
  f(t)
}

inline drop-while-N(pred: (rune) -> bool, t: &text): text {
  let len = text-byte-length(t) in
  let f =
    define self(index: int): text {
      if ge-int(index, len) {
        empty()
      } else {
        let ch = _get-rune(t, index) in
        if pred(ch) {
          let char-len = this.rune.size(ch) in
          self(add-int(index, char-len))
        } else {
          _slice-N(index, len, t)
        }
      }
    }
  in
  f(0)
}

define replicate(n: int, t: &text): text {
  let base-len = text-byte-length(t) in
  let len = mul-int(n, base-len) in
  let u = Word.size in
  let u2 = mul-int(u, 2) in
  let new-text = Ext.malloc(add-int(len, u2)) in
  Mem.store-int(0, new-text);
  Mem.store-int(len, add-int(new-text, u));
  let content-ptr = add-int(new-text, u2) in
  let loop =
    define self(count: int, t: &text): unit {
      if ge-int(count, n) {
        Unit
      } else {
        let current-content-ptr = add-int(content-ptr, mul-int(count, base-len)) in
        let x-ptr = _get-content-pointer(t) in
        _copy-binary(x-ptr, current-content-ptr, 0, base-len);
        self(add-int(count, 1), t)
      }
    }
  in
  loop(0, t);
  magic cast(int, text, new-text)
}

inline fold<a>(acc: a, t: &text, f: (a, rune) -> a): a {
  let len = text-byte-length(t) in
  let f =
    define self(index: int, acc: a): a {
      if ge-int(index, len) {
        acc
      } else {
        let ch = _get-rune(t, index) in
        let char-len = this.rune.size(ch) in
        self(add-int(index, char-len), f(acc, ch))
      }
    }
  in
  f(0, acc)
}

inline all(pred: (rune) -> bool, t: &text): bool {
  let len = text-byte-length(t) in
  let f =
    define self(index: int): bool {
      if ge-int(index, len) {
        True
      } else {
        let ch = _get-rune(t, index) in
        let cond = pred(ch) in
        if cond {
          let char-len = this.rune.size(ch) in
          self(add-int(index, char-len))
        } else {
          False
        }
      }
    }
  in
  f(0)
}

inline any(pred: (rune) -> bool, t: &text): bool {
  let len = text-byte-length(t) in
  let f =
    define self(index: int): bool {
      if ge-int(index, len) {
        False
      } else {
        let ch = _get-rune(t, index) in
        let cond = pred(ch) in
        if cond {
          True
        } else {
          let char-len = this.rune.size(ch) in
          self(add-int(index, char-len))
        }
      }
    }
  in
  f(0)
}
