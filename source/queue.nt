import {
- this.bool [bool, True, False]
- this.except
- this.list [list, Nil, Cons, reverse, length]
- this.pair
- this.unit [unit, Unit]
}

// naive queue
inline queue(a: tau): tau {
  tuple(list(a), list(a))
}

define empty[a](): queue(a) {
  Tuple([], [])
}

define dequeue[a](q: queue(a)): ?tuple(a, queue(a)) {
  let Tuple(ls, rs) = q in
  match ls, rs {
  - Nil, Nil =>
    None
  - Cons(l, ls-rest), rs =>
    Some(Tuple(l, Tuple(ls-rest, rs)))
  - Nil, rs =>
    dequeue(Tuple(rs, []))
  }
}

define enqueue[a](x: a, q: queue(a)): queue(a) {
  let Tuple(ls, rs) = q in
  Tuple(ls, x :: rs)
}

define size[a](q: &queue(a)): int {
  case q {
  - Tuple(ls, rs) =>
    let l1 = length(ls) in
    let l2 = length(rs) in
    add-int(l1, l2)
  }
}

define is-empty[a](q: &queue(a)): bool {
  case q {
  - Tuple([], []) =>
    True
  - _ =>
    False
  }
}
