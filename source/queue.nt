import {
- this.list => [list, Nil, Cons, reverse, length]
- this.either
- this.both
- this.unit => [unit, Unit]
- this.bool => [bool, True, False]
}

// naive queue
inline queue(a: tau): tau {
  tuple(list(a), list(a))
}

define empty[a](): queue(a) {
  Tuple([], [])
}

define dequeue[a](q: queue(a)): ?tuple(a, queue(a)) {
  let Tuple(ls, rs) = q
  match ls, rs {
  - Nil, Nil =>
    None
  - Cons(l, ls-rest), rs =>
    Some(Tuple(l, Tuple(ls-rest, rs)))
  - Nil, rs =>
    // dequeue(Tuple(reverse(rs), []))
    dequeue(Tuple(rs, []))
  }
}

define test-dequeue[a](ls: list(a), rs: list(a)): unit {
  match ls, rs {
  - [], [] =>
    Unit
  - Cons(_, _), _ =>
    Unit
  - [], rs =>
    test-dequeue(rs, [])
  }
}

define enqueue[a](x: a, q: queue(a)): queue(a) {
  let Tuple(ls, rs) = q
  Tuple(ls, x :: rs)
}

define size[a](q: &queue(a)): int {
  case q {
  - Tuple(ls, rs) =>
    let l1 = length(ls)
    let l2 = length(rs)
    add-int(l1, l2)
  }
}

define is-empty[a](q: &queue(a)): bool {
  case q {
  - Tuple([], []) =>
    True
  - _ =>
    False
  }
}
