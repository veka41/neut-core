import {
- this.bool {bool, True, False}
- this.except {Pass, none}
- this.list {list, Nil, Cons, length}
- this.pair
- this.unit
}

// naive queue
data queue(a: tau) {
- Queue(list(a), list(a))
}

define empty<a>(): queue(a) {
  Queue([], [])
}

define dequeue<a>(q: queue(a)): ?tuple(a, queue(a)) {
  let Queue(ls, rs) = q in
  match ls, rs {
  - Nil, Nil =>
    none()
  - Cons(l, ls-rest), rs =>
    Pass(Tuple(l, Queue(ls-rest, rs)))
  - Nil, rs =>
    dequeue(Queue(rs, []))
  }
}

define enqueue<a>(x: a, q: queue(a)): queue(a) {
  let Queue(ls, rs) = q in
  Queue(ls, x :: rs)
}

define size<a>(q: &queue(a)): int {
  case q {
  - Queue(ls, rs) =>
    let l1 = length(ls) in
    let l2 = length(rs) in
    add-int(l1, l2)
  }
}

define is-empty<a>(q: &queue(a)): bool {
  case q {
  - Queue([], []) =>
    True
  - _ =>
    False
  }
}
