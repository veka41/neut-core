import {
  this.binary.eq {eq-binary},
  this.bool {bool},
  this.either {Right, none},
  this.eq {Eq, eq},
  this.text {Text, _drop-N, _take-N, text, text-byte-length},
  this.unit,
}

define eq-text(t1: &text, t2: &text): bool {
  tie Text(xs1) = t1 in
  tie Text(xs2) = t2 in
  eq-binary(xs1, xs2)
}

constant as-eq: eq(&text) {
  Eq of {equal = eq-text}
}

define eq-prefix(needle: &text, haystack: &text): bool {
  tie Text(xs1) = needle in
  tie Text(xs2) = haystack in
  this.binary.eq.eq-prefix(xs1, xs2)
}

define eq-suffix(needle: &text, haystack: &text): bool {
  tie Text(xs1) = needle in
  tie Text(xs2) = haystack in
  this.binary.eq.eq-suffix(xs1, xs2)
}

define eq-infix(needle: &text, haystack: &text): bool {
  tie Text(xs1) = needle in
  tie Text(xs2) = haystack in
  this.binary.eq.eq-infix(xs1, xs2)
}

define strip-prefix(needle: &text, haystack: &text): ?text {
  if eq-prefix(needle, haystack) {
    let needle-len = text-byte-length(needle) in
    Right(_drop-N(needle-len, haystack))
  } else {
    none()
  }
}

define strip-suffix(needle: &text, haystack: &text): ?text {
  if eq-suffix(needle, haystack) {
    let new-haystack-len = sub-int(text-byte-length(haystack), text-byte-length(needle)) in
    Right(_take-N(new-haystack-len, haystack))
  } else {
    none()
  }
}
