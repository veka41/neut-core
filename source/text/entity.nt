import {
  this.bool {bool},
  this.entity {Entity, entity},
  this.except {Pass, none},
  this.int8-array.entity {eq-int8-array},
  this.text {Text, dropN, takeN, text, text-byte-length},
  this.unit,
}

define eq-text(t1: &text, t2: &text): bool {
  tie Text(xs1) = t1 in
  tie Text(xs2) = t2 in
  eq-int8-array(xs1, xs2)
}

constant as-entity: entity(&text) {
  Entity of {identity = eq-text}
}

define eq-prefix(needle: &text, haystack: &text): bool {
  tie Text(xs1) = needle in
  tie Text(xs2) = haystack in
  this.int8-array.entity.eq-prefix(xs1, xs2)
}

define eq-suffix(needle: &text, haystack: &text): bool {
  tie Text(xs1) = needle in
  tie Text(xs2) = haystack in
  this.int8-array.entity.eq-suffix(xs1, xs2)
}

define eq-infix(needle: &text, haystack: &text): bool {
  tie Text(xs1) = needle in
  tie Text(xs2) = haystack in
  this.int8-array.entity.eq-infix(xs1, xs2)
}

define strip-prefix(needle: &text, haystack: &text): ?text {
  if eq-prefix(needle, haystack) {
    let needle-len = text-byte-length(needle) in
    Pass(dropN(needle-len, haystack))
  } else {
    none()
  }
}

define strip-suffix(needle: &text, haystack: &text): ?text {
  if eq-suffix(needle, haystack) {
    let new-haystack-len = sub-int(text-byte-length(haystack), text-byte-length(needle)) in
    Pass(takeN(new-haystack-len, haystack))
  } else {
    none()
  }
}
