include {
- this.bool
- this.external [free, malloc]
- this.list [list, loop, repeat, minimum]
- this.unit [unit, Unit]
- this.except [from-option]
- int
- magic
- mem
- word
}

data _vecInfo {
- _VecInfo of {
  - word-size: int
  - from-ptr: int
  - to-ptr: int
  - type-ptr: int
  - content-ptr: int
  }
}

define _discard-vector-content(ptr: int, elem-type: tau, counter: int, size: int): unit {
  if eq-int(counter, size) {
    Unit
  } else {
    let u = word.size in
    let _ = magic.cast(int, elem-type, mem.load-int(add-int(ptr, mul-int(counter, u)))) in
    _discard-vector-content(ptr, elem-type, add-int(counter, 1), size)
  }
}

define _copy-vector-content(source-pointer: int, target-pointer: int, elem-type: tau, counter: int, size: int): unit {
  if eq-int(counter, size) {
    Unit
  } else {
    let u = word.size in
    let original = magic.cast(int, &elem-type, mem.load-int(add-int(source-pointer, mul-int(counter, u)))) in
    let clone = *original in
    mem.store-int(magic.cast(elem-type, int, clone), add-int(target-pointer, mul-int(counter, u)));
    _copy-vector-content(source-pointer, target-pointer, elem-type, add-int(counter, 1), size)
  }
}

mutual {
  define vector(_: tau): tau {
    vector-internal
  }

  define _get-vec-info[a](xs: &vector(a)): _vecInfo {
    let from-ptr = magic.cast(&vector(a), int, xs) in
    let word-size = word.size in
    let to-ptr = add-int(from-ptr, word-size) in
    let type-ptr = add-int(from-ptr, mul-int(word-size, 2)) in
    let content-ptr = add-int(from-ptr, mul-int(word-size, 3)) in
    _VecInfo of { word-size, from-ptr, to-ptr, type-ptr, content-ptr }
  }

  resource vector-internal {
  - (ptr: int) => {
      let base-ptr = magic.cast(int, &vector(int), ptr) in
      let _VecInfo of { from-ptr, to-ptr, type-ptr, content-ptr } = _get-vec-info(base-ptr) in
      let from: int = mem.load-int(from-ptr) in
      let to: int = mem.load-int(to-ptr) in
      let size = sub-int(to, from) in
      let elem-type = magic.cast(int, tau, mem.load-int(type-ptr)) in
      _discard-vector-content(content-ptr, elem-type, 0, size);
      magic.cast(unit, int, free(from-ptr))
    }
  - (ptr: int) => {
      let base-ptr = magic.cast(int, &vector(int), ptr) in
      let _VecInfo of { word-size, from-ptr, to-ptr, type-ptr, content-ptr } = _get-vec-info(base-ptr) in
      let from: int = mem.load-int(from-ptr) in
      let to: int = mem.load-int(to-ptr) in
      let size = sub-int(to, from) in
      let elem-type: tau = magic.cast(int, tau, mem.load-int(type-ptr)) in
      let target-ptr = malloc(mul-int(word-size, add-int(size, 3))) in
      mem.store-int(0, target-ptr);
      mem.store-int(size, add-int(target-ptr, word-size));
      mem.store-int(magic.cast(tau, int, elem-type), add-int(target-ptr, mul-int(word-size, 2)));
      _copy-vector-content(content-ptr, add-int(target-ptr, mul-int(word-size, 3)), elem-type, 0, size);
      target-ptr
    }
  }
}

define new[a](base-list: list(a)): vector(a) {
  let word-size = word.size in
  let n on base-list = this.list.length(base-list) in
  let ptr0 = malloc(mul-int(word-size, add-int(3, n))) in
  let ptr1 = add-int(ptr0, word-size) in
  let ptr2 = add-int(ptr0, mul-int(word-size, 2)) in
  let ptr3 = add-int(ptr0, mul-int(word-size, 3)) in
  mem.store-int(0, ptr0);
  mem.store-int(n, ptr1);
  mem.store-int(magic.cast(tau, int, a), ptr2);
  let store-values =
    mu self(values: list(a), index: int): unit {
      match values {
      - [] =>
        Unit
      - v :: rest =>
        mem.store-int(magic.cast(a, int, v), add-int(ptr3, mul-int(index, word-size)));
        self(rest, add-int(index, 1))
      }
    }
  in
  let _ = store-values(base-list, 0) in
  magic cast(int, _, ptr0)
}

inline access[a](xs: &vector(a), i: int): a {
  let _VecInfo of { from-ptr, content-ptr, word-size } = _get-vec-info(xs) in
  let from = mem.load-int(from-ptr) in
  let elem-address = add-int(content-ptr, mul-int(word-size, add-int(from, i))) in
  let val = magic.cast(int, &a, mem.load-int(elem-address)) in
  *val
}

inline access-N[a](xs: &vector(a), i: int): &a {
  let _VecInfo of { from-ptr, content-ptr, word-size } = _get-vec-info(xs) in
  let from = mem.load-int(from-ptr) in
  let elem-address = add-int(content-ptr, mul-int(word-size, add-int(from, i))) in
  magic.cast(int, &a, mem.load-int(elem-address))
}

define size[a](xs: &vector(a)): int {
  let _VecInfo of { from-ptr, to-ptr } = _get-vec-info(xs) in
  let from = mem.load-int(from-ptr) in
  let to = mem.load-int(to-ptr) in
  sub-int(to, from)
}

inline for-each[a](xs: &vector(a), f: a -> unit): unit {
  loop(size(xs), (i) => {
    f(access(xs, i))
  })
}

inline for[a, b](xs: &vector(a), f: a -> b): vector(b) {
  new of {
  - base-list =
    repeat(size(xs), (i) => {
      f(access(xs, i))
    })
  }
}

inline fold-LN[elem-type, result-type] of {
- acc: result-type
- xs: &vector(elem-type)
- consumer: (result-type, &elem-type) -> result-type
}: result-type {
  let sz = size(xs) in
  let helper =
    mu loop(cursor: int, acc, xs) {
      if eq-int(cursor, sz) {
        acc
      } else {
        let y = access-N(xs, cursor) in
        loop(add-int(cursor, 1), consumer(acc, y), xs)
      }
    }
  in
  helper(0, acc, xs)
}

define zip-with[a, b, c](xs: &vector(a), ys: &vector(b), f: (a, b) -> c): vector(c) {
  let len1 = size(xs) in
  let len2 = size(ys) in
  let min-func = minimum(int.as-loset) in
  let len-or-none = min-func([len1, len2]) in
  let len = from-option(0, len-or-none) in
  let zip-with-helper =
    mu self(cursor: int) {
      if eq-int(cursor, len) {
        []
      } else {
        let val1 = access(xs, cursor) in
        let val2 = access(ys, cursor) in
        f(val1, val2) :: self(add-int(cursor, 1))
      }
    }
  in
  new(zip-with-helper(0))
}
