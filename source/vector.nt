import {
- this.bool
- this.top
- this.list
- this.external
- this.memory => mem
- this.magic => magic
}

export {
- vector
- vector-new
- vector-access
- this.vector.length
}

define discard-vector-content(ptr: i64, elem-type: tau, counter: i64, length: i64): top {
  if eq-i64(counter, length) {
    Unit
  } else {
    let _ = magic.cast(i64, elem-type, mem.load-i64(add-i64(ptr, mul-i64(counter, 8))))
    discard-vector-content(ptr, elem-type, add-i64(counter, 1), length)
  }
}

define copy-vector-content(source-pointer: i64, target-pointer: i64, elem-type: tau, counter: i64, length: i64): top {
  if eq-i64(counter, length) {
    Unit
  } else {
    let original = magic.cast(i64, &elem-type, mem.load-i64(add-i64(source-pointer, mul-i64(counter, 8))))
    let clone = !original
    mem.store-i64(add-i64(target-pointer, mul-i64(counter, 8)), magic.cast(elem-type, i64, clone))
    copy-vector-content(source-pointer, target-pointer, elem-type, add-i64(counter, 1), length)
  }
}

resource vector-internal {
- lambda(x: i64) {
    let length = mem.load-i64(x)
    let elem-type = magic.cast(i64, tau, mem.load-i64(add-i64(x, 8)))
    discard-vector-content(add-i64(x, 16), elem-type, 0, length)
    magic.cast(top, i64, free(x))
  }
- lambda(source-pointer: i64) {
    let length: i64 = mem.load-i64(source-pointer)
    let elem-type: tau = magic.cast(i64, tau, mem.load-i64(add-i64(source-pointer, 8)))
    let target-pointer = malloc(add-i64(16, mul-i64(length, 8)))
    mem.store-i64(target-pointer, length)
    mem.store-i64(add-i64(target-pointer, 8), magic.cast(tau, i64, elem-type))
    copy-vector-content(add-i64(source-pointer, 16), add-i64(target-pointer, 16), elem-type, 0, length)
    target-pointer
  }
}

define vector(_: tau): tau {
  vector-internal
}

define vector-new[a](xs: list(a)): vector(a) {
  let len on xs = this.list.length(xs)
  let base-pointer = malloc(add-i64(16, mul-i64(len, 8)))
  mem.store-i64(base-pointer, len)
  mem.store-i64(add-i64(base-pointer, 8), magic.cast(tau, i64, a))
  let content-pointer: i64 = add-i64(base-pointer, 16)
  let store-values =
    define self(values: list(a), index: i64): top {
      match values {
      - [] =>
        Unit
      - v :< rest =>
        mem.store-i64(add-i64(content-pointer, mul-i64(index, 8)), magic.cast(a, i64, v))
        self(rest, add-i64(index, 1))
      }
    }
  let _ = store-values(xs, 0)
  magic cast(i64, vector(a), base-pointer)
}

define-inline vector-access[a](xs: &vector(a), i: i64): a {
  let ptr = magic.cast(&vector(a), i64, xs)
  magic.cast(i64, a, mem.load-i64(add-i64(add-i64(ptr, 16), mul-i64(8, i))))
}

define length[a](xs: &vector(a)): i64 {
  let ptr = magic.cast(&vector(a), i64, xs)
  mem.load-i64(ptr)
}
