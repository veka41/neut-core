import {
- this.top
- this.list
}

define discard-vector-content(ptr: i64, elem-type: tau, counter: i64, length: i64): top {
  if eq-i64(counter, length) {
    Unit
  } else {
    let _: elem-type = magic load(pointer(i8), add-i64(ptr, mul-i64(counter, 8)))
    discard-vector-content(ptr, elem-type, add-i64(counter, 1), length)
  }
}

define copy-vector-content(source-pointer: i64, target-pointer: i64, elem-type: tau, counter: i64, length: i64): top {
  if eq-i64(counter, length) {
    Unit
  } else {
    let value: elem-type = magic load(pointer(i8), add-i64(source-pointer, mul-i64(counter, 8)))
    let original = value
    let clone = value
    let _ = magic cast(elem-type, i64, original)
    let _: i64 = magic store(pointer(i8), add-i64(target-pointer, mul-i64(counter, 8)), clone)
    copy-vector-content(source-pointer, target-pointer, elem-type, add-i64(counter, 1), length)
  }
}

resource vector-internal {
- lambda(x: i64) {
    let length: i64 = magic load(i64, x)
    let elem-type: tau = magic load(i64, add-i64(x, 8))
    let _ = discard-vector-content(add-i64(x, 16), elem-type, 0, length)
    magic external(free, x)
  }
- lambda(source-pointer: i64) {
    let length: i64 = magic load(i64, source-pointer)
    let elem-type: tau = magic load(i64, add-i64(source-pointer, 8))
    let target-pointer = magic external(malloc, add-i64(16, mul-i64(length, 8)))
    let _: i64 = magic store(i64, target-pointer, length)
    let _: i64 = magic store(i64, add-i64(target-pointer, 8), elem-type)
    let _ = copy-vector-content(add-i64(source-pointer, 16), add-i64(target-pointer, 16), elem-type, 0, length)
    target-pointer
  }
}

define vector(a: tau): tau {
  vector-internal
}

define vector-new[a](xs: list(a)): vector(a) {
  let len on xs = this.list.length(xs)
  let base-pointer = magic external(malloc, add-i64(16, mul-i64(len, 8)))
  let _: i64 = magic store(i64, base-pointer, len)
  let _: i64 = magic store(i64, add-i64(base-pointer, 8), a)
  let content-pointer: i64 = add-i64(base-pointer, 16)
  let store-values =
    define self(values: list(a), index: i64): top {
      match values {
      - [] =>
        Unit
      - v :< rest =>
        let _: i64 = magic store(pointer(i8), add-i64(content-pointer, mul-i64(index, 8)), v)
        self(rest, add-i64(index, 1))
      }
    }
  let _ = store-values(xs, 0)
  magic cast(i64, vector(a), base-pointer)
}

define-inline vector-access[a](xs: &vector(a), i: i64): a {
  let ptr = magic cast(&vector(a), i64, xs)
  magic load(pointer(i8), add-i64(add-i64(ptr, 16), mul-i64(8, i)))
}

define length[a](xs: &vector(a)): i64 {
  let ptr = magic cast(&vector(a), i64, xs)
  magic load(i64, ptr)
}
