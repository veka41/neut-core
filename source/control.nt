import {
  core.bool {False, True},
  core.except {OK, except},
  core.unit {Unit, unit},
}

inline loop(count: int, !f: (int) -> unit): unit {
  let helper =
    define self(cursor): unit {
      match ge-int(cursor, count) {
      | True =>
        Unit
      | False =>
        !f(cursor);
        self(add-int(cursor, 1))
      }
    }
  in
  helper(0)
}

inline loop-E<e>(count: int, !f: (int) -> except(e, unit)): except(e, unit) {
  let helper =
    define self(cursor): except(e, unit) {
      match ge-int(cursor, count) {
      | True =>
        OK(Unit)
      | False =>
        try _ = !f(cursor) in
        self(add-int(cursor, 1))
      }
    }
  in
  helper(0)
}

inline grow<a>(seed: a, iteration: int, !step: (a, int) -> a): a {
  let helper =
    define self(acc: a, current: int): a {
      if ge-int(current, iteration) {
        acc
      } else {
        self(!step(acc, current), add-int(current, 1))
      }
    }
  in
  helper(seed, 0)
}

inline grow-E<e, a>(seed: a, iteration: int, !step: (a, int) -> except(e, a)): except(e, a) {
  let helper =
    define self(acc: a, current: int): except(e, a) {
      if ge-int(current, iteration) {
        OK(acc)
      } else {
        try tmp = !step(acc, current) in
        self(tmp, add-int(current, 1))
      }
    }
  in
  helper(seed, 0)
}

define discard<a>(_: a): unit {
  Unit
}
